*syntax.txt*	Для Vim version 6.3.  Последнее изменение: 2004 Jun 04


		      СПРАВОЧНИК ПО VIM - Брам Мооленаар


                                     *syntax* *syntax-highlighting* *coloring*
Подсветка синтаксиса	         *синтаксис* *синтаксис-подсветка* *подсветка*

Подсветка синтаксиса позволяет Vim выделять некоторые фрагменты текста с
помощью шрифта или цвета. Такими фрагментами могут быть определённые ключевые
слова или текст, соответствующий определённому шаблону. Vim не выполняет
разбор всего файла целиком, чтобы подсветка могла работать быстро, поэтому
такое выделение имеет ряд ограничений. Более подходящим названием был бы
термин "лексическая подсветка", однако мы будем применять термин "подсветка
синтаксиса", поскольку он является более общепринятым.

Vim обеспечивает подсветку синтаксиса на всех терминалах, однако, поскольку
большинство обычных терминалов имеет очень ограниченные возможности подсветки,
лучше всего она работает в версии Vim для графического интерфейса, gvim.

См. также информацию в Руководстве пользователя:

|usr_06.txt| введение в подсветку синтаксиса
|usr_44.txt| общие сведения о написании сценария подсветки синтаксиса

1.  С чего начать?			            |:syn-для_начала|
2.  Сценарии подсветки синтаксиса	            |:syn-файлы|
3.  Последовательность загрузки правил синтаксиса   |синтаксис-загрузка|
4.  Замечания к сценариям подсветки		    |:syn-файлы-замечания|
5.  Определение синтаксических правил               |:syn-определение|
6.  Параметры команды :syntax 	                    |:syn-параметры|
7.  Шаблоны в команде syntax                        |:syn-шаблон|
8.  Синтаксические кластеры                         |:syn-кластеры|
9.  Подключение других сценариев синтаксиса         |:syn-подключение|
10. Синхронизация	                            |:syn-синхронизация|
11. Вывод списка синтаксических элементов           |:syntax|
12. Команда подсветки :highlight                    |:highlight|
13. Связывание групп	                            |:highlight-link|
14. Очистка синтаксиса				    |:syn-clear|
15. Подсветка меток				    |метки-подсветка|
16. Цветные терминалы xterm			    |xterm-цвет|

{Vi не поддерживает ни одной из перечисленных команд}

Подсветка синтаксиса недоступна, если при компиляции не была включена
особенность |+syntax|.

==============================================================================
1. С чего начать?	                       *:syn-qstart* *:syn-для_начала*

						*:syn-enable* *:syntax-enable*
Нижеследующая команда включает подсветку синтаксиса:
>
	:syntax enable

На самом деле, выполнение этой команды приводит к выполнению "за кулисами"
команды
>
	:source $VIMRUNTIME/syntax/syntax.vim

Если переменная окружения VIM не настроена, то Vim будет пытаться определить
необходимый путь к этому сценарию другими способами (см. |$VIMRUNTIME|). Как
правило, автоматический поиск срабатывает без проблем, но если у вас он не
работает, то попробуйте присвоить переменной окружения VIM путь к каталогу, 
в котором размещены файлы Vim. Например, если сценарии подсветки синтаксиса
находятся в каталоге "/usr/vim/vim50/syntax", то присвойте переменной
окружения $VIMRUNTIME значение "/usr/vim/vim50". Это следует выполнить 
в оболочке до запуска Vim.

							*:syn-on* *:syntax-on*
Команда ":syntax enable" сохраняет текущие цветовые настройки, что позволяет
использовать команды ":highlight" до или после выполнения этой команды. Если
вы желаете, чтобы Vim переопределил ваши настройки принятыми по умолчанию, то
используйте команду 
>
	:syntax on
<
					      *:hi-normal* *:highlight-normal*
Если вы работаете в режиме графического интерфейса, то вы можете добиться
белого текста на чёрном фоне при помощи команды 
>
	:highlight Normal guibg=Black guifg=White
	
О цветных терминалах рассказано в разделе |:hi-normal-cterm|.
Настройка собственных цветов для подсветки синтаксиса обсуждается 
в разделе |syncolor|.

ЗАМЕЧАНИЕ: строки в сценариях подсветки синтаксиса в MS-DOS и Windows
завершаются символами <CR><NL>, в то время как в Unix соответствующие файлы
завершаются символом <NL>. Это значит, что вам необходимо использовать
на вашей системе правильный файл. В то же время, в MS-DOS и Windows
необходимый формат выбирается автоматически, если значение опции
'fileformats' не является пустым.

ЗАМЕЧАНИЕ: при использовании режима инверсного видео ("gvim -fg white -bg
black"), значение опции 'background' по умолчанию не будет назначено до тех
пор, пока не будет открыто окно графического интерфейса, что происходит после
выполнения сценария .gvimrc. Это приводит к использованию неправильной
подсветки синтаксиса по умолчанию. Чтобы назначить значение опции 'background'
по умолчанию перед включением подсветки синтаксиса, добавьте в файл .gvimrc
команду ":gui":
>
   :gui		" открыть окно и назначить опции 'background' значение по
                " умолчанию
   :syntax on	" включить подсветку синтаксиса с использованием значения
                " опции 'background' для настройки цветов

ЗАМЕЧАНИЕ: Использовании команды ":gui" в файле .gvimrc означает, что команда
"gvim -f" не будет запускать Vim в активной задаче! Для этой цели следует
использовать ":gui -f".


Включать и отключать использование подсветки синтаксиса можно с помощью
команды
>
   :if exists("syntax_on") | syntax off | else | syntax enable | endif

Вы можете назначить для этой команды привязку:
>
   :map <F7> :if exists("syntax_on") <Bar>
	\   syntax off <Bar>
	\ else <Bar>
	\   syntax enable <Bar>
	\ endif <CR>

[используется соглашение |<>|, т.е. приведённый код следует вводить как
написано]

Подробности

Команда ":syntax" реализована путём считывания специальных сценариев.
Подробности работы этой команды можно изучить в следующих файлах:

    команда		файл ~
    
    :syntax enable	$VIMRUNTIME/syntax/syntax.vim
    :syntax on		$VIMRUNTIME/syntax/syntax.vim
    :syntax manual	$VIMRUNTIME/syntax/manual.vim
    :syntax off		$VIMRUNTIME/syntax/nosyntax.vim

См. также |синтаксис-загрузка|.

==============================================================================
2. Сценарии подсветки синтаксиса	             *:syn-files* *:syn-файлы*

Команды настройки синтаксиса и подсветки для одного языка как правило
сохраняются в одном файле сценария синтаксиса. Соглашение об имени такого
файла следующее: "{имя}.vim", где {имя} это название соответствующего языка,
либо его сокращённое название (имя файла должно соответствовать формату 8.3,
чтобы его можно было использовать на файловой системе DOS).

Примеры:

	c.vim		perl.vim	java.vim	html.vim
	cpp.vim		sh.vim		csh.vim

Файл синтаксиса может содержать любые команды Ex, как сценарий vimrc. Однако,
обычно в него включаются только команды, относящиеся к определённому языка.
Если язык является расширением другого языка, то он может подключать другой
сценарий синтаксиса; например, файл cpp.vim может включать файл c.vim:
>
   :so $VIMRUNTIME/syntax/c.vim

Файлы .vim обычно загружаются с помощью автокоманд. Например:
>
   :au Syntax c	    runtime! syntax/c.vim
   :au Syntax cpp   runtime! syntax/cpp.vim

Эти команды обычно помещаются в файле $VIMRUNTIME/syntax/synload.vim.


                                                                *mysyntaxfile*
СОЗДАНИЕ СОБСТВЕННОГО СЦЕНАРИЯ ПОДСВЕТКИ СИНТАКСИСА     *свой_файл_синтаксиса*

Если вы создали собственные сценарии подсветки синтаксиса и хотите, чтобы Vim
использовал их автоматически при выполнении команды ":syntax enable", то вам
необходимо выполнить следующее:

1. Создать собственный каталог рабочей среды. Обычно для этого используется
   первое значение в списке в опции 'runtimepath'. Например, для Unix:
>
	mkdir ~/.vim

2. Создать подкаталог в этом каталоге с именем "syntax". Например, для Unix:
>
	mkdir ~/.vim/syntax

3. Поместить файл сценария подсветки синтаксиса в этот каталог. Вы можете
   написать собственный сценарий, или загрузить его из интернета. Например,
   для файла сценария подсветки синтаксиса "mine":
>
	:w ~/.vim/syntax/mine.vim

Теперь вы можете начать пользоваться этим сценарием вручную:
>
	:set syntax=mine

Вам не нужно перезапускать Vim для выполнения этой команды.

В том случае, если вам необходимо, чтобы Vim автоматически определял тип
файла, обратитесь к разделу |новый_тип_файла|.

Наконец, если вы настраиваете многопользовательскую систему и хотите, чтобы
один и тот же сценарий подсветки синтаксиса был доступен для всех
пользователей сразу, можно использовать общесистемный каталог из значения
опции 'runtimepath'.


	                                                    *mysyntaxfile-add*
			                     *свой_файл_синтаксиса-дополнение*
ДОПОЛНЕНИЯ К СУЩЕСТВУЮЩЕМУ СЦЕНАРИЮ СИНТАКСИСА 

Если существующий сценарий синтаксиса вас в целом устраивает, но вы хотели бы
изменить подсветку или добавить несколько дополнительных элементов, проделайте
следующее:

1. Создайте собственный каталог рабочей среды, определённый в значении опции
   'runtimepath', как это описано выше.

2. Создайте подкаталоги в этом каталоге, с именами "after/syntax". Например,
   для Unix:
>
	mkdir ~/.vim/after
	mkdir ~/.vim/after/syntax

3. Напишите сценарий Vim, содержащий необходимые команды. Например, для
   изменения цвета при подсветке исходного кода на языке C:
>
	highlight cComment ctermfg=Green guifg=Green

4. Сохраните созданный файл сценария в каталоге "after/syntax". Используете
   имя соответствующего языка с добавлением расширения ".vim". Например, в
   случае сценария дополнений к правилам подсветки синтаксиса исходного кода
   на языке C:
>
	:w ~/.vim/after/syntax/c.vim

Вот и всё. В следующий раз, когда вы станете редактировать файл с исходным
кодом на языке C, комментарии будут отображаться другим цветом. Вам даже не
потребуется перезапускать Vim.


		                                        *mysyntaxfile-replace*
ЗАМЕНА СУЩЕСТВУЮЩЕГО СЦЕНАРИЯ ПОДСВЕТКИ	         *свой_файл_синтаксиса-замена*

Если вас совершенно не устраивает сценарий подсветки синтаксиса, включённый в
поставку редактора, или у вас есть обновлённая версия этого сценария, следуйте
инструкциям, приведённым выше в разделе |свой_файл_синтаксиса|. Убедитесь
только, что вы помещаете свой вариант сценария в один из каталогов, который
упоминается в начале списка, указанного в значении опции 'runtimepath'. Vim
загружает только первый найденный сценарий подсветки синтаксиса.


				                   *group-name* *{group-name}*
СОГЛАШЕНИЯ ОБ ИМЕНАХ                *группы-имена* *{имя-группы}* *E669* *W18*

Имя группы подсветки или синтаксиса может содержать символы ASCII, цифры и
символ подчёркивания, иными словами, в виде регулярного выражения:
"[a-zA-Z0-9_]*".

Чтобы пользователи могли применять собственные наборы цветов, должны быть
предпочтительные имена для групп подсветки синтаксиса, которые используются в
самых различных языках. Предлагается использовать следующие имена групп (если
подсветка синтаксиса настроена правильно, то вы можете видеть настоящий цвет,
за исключением группы "Ignore"):

	*Comment	любой комментарий

	*Constant	любая константа
	 String		строковая константа: "это строка"
	 Character	символьная константа: 'c', '\n'
	 Number		числовая константа: 234, 0xff
	 Boolean	булева константа: TRUE, false
	 Float		константа с плавающей точкой: 2.3e10

	*Identifier	любое имя переменной
	 Function	имя функции (также методы в классах)

	*Statement	любое предложение
	 Conditional	if, then, else, endif, switch и т.п.
	 Repeat		for, do, while и т.п.
	 Label		case, default и т.п.
	 Operator	"sizeof", "+", "*" и т.п.
	 Keyword	любое другое ключевое слово
	 Exception	try, catch, throw

	*PreProc	код для препроцессора
	 Include	#include в коде для препроцессора
	 Define		#define в коде для препроцессора
	 Macro		то же, что и Define
	 PreCondit	#if, #else, #endif в коде для препроцессора

	*Type		int, long, char и т.п.
	 StorageClass	static, register, volatile и т.п.
	 Structure	struct, union, enum и т.п.
	 Typedef	определение типа typedef

	*Special	любой спецсимвол
	 SpecialChar	спецсимвол в константе
	 Tag		на этом элементе работает команда CTRL-]
	 Delimiter	символ, требующий внимания
	 SpecialComment	особые элементы внутри комментария
	 Debug		отладочные предложения

	*Underlined	выделенный текст, ссылки в HTML

	*Ignore		скрытые, не отображаемые элементы

	*Error		любая конструкция с ошибкой

	*Todo		всё, что может требовать дополнительного внимания,
			в основном это слова вроде TODO (СДЕЛАТЬ), FIXME
			(ИСПРАВИТЬ) и XXX

Имена, отмеченные символом *, являются предпочтительными; остальные имена
являются подгруппами. В файле "syntax.vim" содержатся правила подсветки по
умолчанию для предпочтительных групп. Подгруппы связаны с соответствующими
предпочтительными группами, поэтому они наследуют от них подсветку. Вы можете
использовать команду ":highlight", чтобы переопределить значения по умолчанию
после считывания файла "syntax.vim".

Обратите внимание, что имена групп подсветки не являются регистрозависимыми.
Вы можете ссылаться на одну и ту же группу как по имени "String", так и по
имени "string".

Следующие имена являются зарезервированными и не могут быть использованы в
качестве имени группы:

	NONE   ALL   ALLBUT   contains	 contained

==============================================================================
                                                              *syntax-loading*
3. Последовательность загрузки правил синтаксиса          *синтаксис-загрузка*

Ниже подробно описывается, что происходит при выполнении команды 
":syntax enable". При запуске Vim выясняет, где размещены файлы рабочей
среды: мы используем здесь в этом качестве значение переменной |$VIMRUNTIME|.

При выполнении команд ":syntax enable" и ":syntax on" происходит следующее:

    Считывается для исполнения сценарий $VIMRUNTIME/syntax/syntax.vim
    |
    +-	Старые правила подсветки синтаксиса очищаются путём выполнения
    |   сценария $VIMRUNTIME/syntax/nosyntax.vim
    |
    +-	Выполняется первый найденный в 'runtimepath' сценарий 
    |   syntax/synload.vim
    |	|
    |	+-  Выполняется настройка цветов для подсветки синтаксиса. Если
    |   |   определена цветовая схема, то она загружается заново по команде
    |   |   ":colors {имя}". В противном случае используется команда 
    |   |   ":runtime! syntax/syncolor.vim". Команда ":syntax on"
    |   |   переопределяет существующие цвета, а команда ":syntax enable"
    |   |   включает только те группы, которые ещё не были включены.
    |	|
    |   |                                  *synload-1* *загрузка_синтаксиса-1*
    |	+-  Настраиваются автокоманды синтаксиса для загрузки соответствующего
    |   |   сценария подсветки синтаксиса при изменении значения опции
    |   |   'syntax'
    |	|
    |   |                                  *synload-2* *загрузка_синтаксиса-2*
    |	+-  Считывается необязательный пользовательский файл, на
    |       который указывает переменная |mysyntaxfile|. Этот шаг выполняется
    |       для обеспечения обратной совместимости с Vim 5.x.
    |
    |
    +-	Выполняется команда ":filetype on", которая приводит к выполнению
    |   команды ":runtime! filetype.vim".  Она загружает все обнаруженные
    |   сценарии filetype.vim.  При этом выполняется сценарий 
    |	$VIMRUNTIME/filetype.vim, который выполняет следующие вещи:
    |	|
    |   |                                  *synload-3* *загрузка_синтаксиса-3*
    |	+-  Включаются автокоманды, полагающиеся на расширение файла для
    |   |   настройки значения опции 'filetype'. На этом этапе создаётся связь
    |   |   между именем файла и типом файла для известных типов файла.
    |	|
    |   |                                  *synload-4* *загрузка_синтаксиса-4*
    |	+-  Считывается необязательный пользовательский файл, на который
    |   |   указывает переменная *myfiletypefile* . Этот шаг выполняется для
    |   |   обеспечения обратной совместимости с Vim 5.x. 
    |	|
    |   |                                  *synload-5* *загрузка_синтаксиса-5*
    |	+-  Включаются автокоманда, которая считывает для исполнения сценарий
    |   |   scripts.vim в тех случаях, когда тип файла всё ещё не определён.
    |	|
    |	+-  Исполняется сценарий $VIMRUNTIME/menu.vim, который настраивает
    |       меню "Синтаксис". |menu.vim|
    |
    |                                      *synload-6* *загрузка_синтаксиса-6*
    +-	Включается автокоманда FileType, которая настраивает значение опции
    |   'syntax', когда тип файла определён.
    |
    +-	Выполняются автокоманды синтаксиса, которые включают подсветку
        синтаксиса в каждом из уже загруженных буферов.


После загрузки нового файла Vim определяет необходимый файл правил подсветки
синтаксиса следующим образом:

    При загрузке файла выполняются автокоманды BufReadPost.
    |
    +-	Если имеется соответствие одной из автокоманд, определённых на этапе
    |   |загрузка_синтаксиса-3| (известные типы файла) или на этапе 
    |   |загрузка_синтаксиса-4| (типы файла, определённые пользователем), 
    |   то значение опции 'filetype' изменяется соответствующим образом.
    |
    +-	Выполняются автокоманды, определённые на этапе
    |   |загрузка_синтаксиса-5|. Если тип файла всё ещё не определён, то
    |   происходит поиск сценария scripts.vim в каталогах, определённых в 
    |   'runtimepath'. При этом должен выполняться сценарий
    |   $VIMRUNTIME/scripts.vim, который делает следующее:
    |	|
    |	+-  Считывается необязательный пользовательский файл, на который
    |   |   указывает переменная *myscriptsfile* . Этот шаг выполняется для
    |   |   обеспечения обратной совместимости с Vim 5.x.
    |	|
    |	+-  Если тип файла по прежнему неизвестен, выполняется проверка
    |	    содержимого файла, например, "getline(1) =~ шаблон", с целью
    |       выяснения типа файла, после чего изменяется значение опции
    |       'filetype'.
    |
    +-	После определения типа файла и настройки значения опции 'filetype'
    |   происходит выполнение автокоманд FileType, определённых на этапе
    |   |загрузка_синтаксиса-6|. Значение опции 'syntax' изменяется в
    |   соответствии с определённым типом файла.
    |
    +-	После изменения значения опции 'syntax' происходит выполнение
    |   автокоманд, определённых на этапе |загрузка_синтаксиса-1| (а также на
    |   этапе |загрузка_синтаксиса-2|). При этом выполняется загрузка
    |   основного сценария подсветки синтаксиса, найденного в одном из
    |   каталогов, перечисленных в значении опции 'runtimepath', по команде:
    |
    |		runtime! syntax/<имя>.vim
    |
    +-	Наконец, вызываются все остальные определённые автокоманды,
        соответствующие событиям FileType и Syntax, что может быть
	использовано для изменения подсветки в особых случаях.

==============================================================================
	                                                   *:syn-file-remarks*
4. Замечания к сценариям подсветки	                *:syn-файлы-замечания*

	             *b:current_syntax-variable* *b:current_syntax-переменная*
Vim сохраняет имя загруженных правил синтаксиса в переменной
"b:current_syntax". Этим можно воспользоваться, когда возникает необходимость
выполнения других настроек в зависимости от активных правил синтаксиса.
Например: 
>
   :au BufReadPost * if b:current_syntax == "csh"
   :au BufReadPost *   do-some-things
   :au BufReadPost * endif


2HTML		         *2html.vim* *convert-to-HTML* *преобразование_в_HTML*

Этот сценарий не является сценарием подсветки синтаксиса, но позволяет
преобразовать содержимое активного окна в HTML. При этом Vim загружает
полученный HTML-файл в новом окне.

При выполнении "2html" вы не должны изменять значение опций 'filetype' и
'syntax'! Вместо этого для выполнения преобразования следует считать
соответствующий сценарий:
>

	:runtime! syntax/2html.vim
<
Предупреждение: Преобразование может быть медленным!
							             *:TOhtml*
Вы можете также воспользоваться командой пользователя ":TOhtml", которая
определена в стандартном модуле. ":TOhtml" может работать с диапазонами и
Визуально выделенными областями:
>

	:10,40TOhtml

После сохранения полученного файла, он может быть просмотрен в любой программе
для просмотра HTML, например в Mozilla Firefox. Цвета в полученном файле
должны быть точно такими же, как вы их видите в Vim.

Чтобы ограничить диапазон строк для выполнения преобразования, назначьте
переменным "html_start_line" и "html_end_line" соответственно первую и
последнюю строку диапазона. Например, чтобы использовать последнюю Визуально
выделенную область:
>
	:let html_start_line = line("'<")
	:let html_end_line = line("'>")

Строки нумеруются в соответствии со значением опции 'number' и настройками
группы подсветки Number. Чтобы выполнить принудительную нумерацию строк в
полученном файле HTML следует назначить переменной "html_number_lines"
ненулевое значение:
>
   :let html_number_lines = 1

Для принудительного отказа от нумерации строк присвойте этой переменной
нулевое значение:
>
   :let html_number_lines = 0

Чтобы вернуться к принятому по умолчанию использованию значения опции 'number'
для определения необходимости выполнения нумерации строк, удалите эту
переменную:
>
   :unlet html_number_lines

По умолчанию создаётся HTML-код, оптимизированный для старых программ для
просмотра HTML. Если вам больше нравится код с использованием каскадных таблиц
стилей (CSS1), что приводит к существенно более короткому и соответствующему
стандарту HTML 4 файлу, воспользуйтесь следующей командой:
>
   :let html_use_css = 1

По умолчанию код HTML обёртывается в тэги <pre> и </pre>. Это позволяет
показать текст на странице в точности так же, как вы его видите в Vim, с
переносами строк. Если вы предпочитаете, чтобы строки в тексте не
переносились, то используйте
>
   :let html_no_pre = 1

хотя в этом случае текст на странице может выглядеть иначе. В этом случае в
конце каждой строки используется тэг <br>, а на месте каждого пробела
используется "&nbsp;".

Для определения кодировки файла HTML используется текущее значение опции
'encoding'. В то же время, это работает только для тех значений 'encoding',
для которых имеется эквивалентное название кодировки HTML. Чтобы
переопределить кодировку вручную, используйте переменную g:html_use_encoding.
Например:
>
   :let html_use_encoding = "foobar"
   
Чтобы исключить из кода HTML строку с указанием кодировки, присвойте
переменной g:html_use_encoding пустую строку:
>
   :let html_use_encoding = ""

Чтобы вернуться к использованию автоматического механизма работы с
кодировками, удалите переменную g:html_use_encoding:
>
   :unlet html_use_encoding
<
					    *convert-to-XML* *convert-to-XHTML*
			        *преобразование_в_XML* *преобразование_в_XHTML*
Вы можете также использовать этот сценарий для преобразования текста в формат
XHTML (XML-совместимый вариант HTML). Для этого достаточно назначить
переменную "use_xhtml":
>
    :let use_xhtml = 1
    
Для отключения преобразования в формат XHTML следует удалить эту переменную:
>
    :unlet use_xhtml

Созданный таким образом файл XHTML можно использовать в документах 
DocBook XML. Подробности см. по адресу:

	http://people.mech.kuleuven.ac.be/~pissaris/howto/src2db.html

Замечания:

- Это работает только в версии с поддержкой графического интерфейса. Если
  графический интерфейс не запущен (что возможно в X11), то преобразование
  будет выполняться, но не совсем качественно (возможно неправильное
  отображение цветов).
- Старые программы для просмотра HTML могут не показывать цвет фона.
- Вы можете распечатать файл в цвете в большинстве программ для просмотра
  HTML.

Пример запуска этого сценария для всех файлов .c и .h из оболочки Unix:
>
   for f in *.[ch]; \
   do gvim -f +"syn on" +"run! syntax/2html.vim" +"wq" +"q" $f; done
<

ABEL				     *abel.vim* *abel-syntax* *abel-синтаксис*

Подсветка синтаксиса для ABEL позволяет пользователю выполнять дополнительные
настройки. Чтобы включить ту или иную возможность подсветки, присвойте любое
значение соответствующей переменной. Например:
>
	:let abel_obsolete_ok=1

Для отключения возможности просто удалите соответствующую переменную.
Например:
>
	:unlet abel_obsolete_ok

Переменная			Подсветка ~
abel_obsolete_ok		Устаревшие ключевые слова подсвечиваются как
				предложения, а не как ошибки
abel_cpp_comments_illegal	Не воспринимать '//' в качестве начала
				внутристрочного комментария


ADA				        *ada.vim* *ada-syntax* *ada-синтаксис*

Поставляемый сценарий подсветки синтаксиса создан для редакции Ada 
от 1995 года ("Ada95"), которая включает поддержку объектно-ориентированного
программирования, защищённых типов и т.д. При этом код, написанный для
оригинального языка Ada ("Ada83" или "Ada87") также поддерживается, хотя
подсветка кода, написанного на Ada83 и использующего ключевые слова Ada95
может быть неправильной (такой код всё равно необходимо исправлять).
Дополнительную информацию об Ada можно найти по адресу
http://www.adapower.com.

Правила синтаксиса для Ada правильно работают в ряде ситуаций. Например, "-" в
"-5" верно определяется как число, в то время как тот же самый символ в "A-5"
распознаётся как оператор. Как правило слово "with" или "use", ссылающееся на
другой блок компиляции, подсвечивается так же, как и "#include" в языке C.
Если группа "Conditional" или "Repeat" в вашем случае подсвечивается как-то
иначе, то "end if" и "end loop" будут подсвечиваться в соответствии с
правилами своей группы.

Вы можете назначить другие цвета при помощи команды Vim "highlight". Например,
для изменения отображения циклов введите команду ":hi Repeat" с определением
соответствующего цвета. На простых терминалах хорошо работает определение
цвета ctermfg=White).

При использовании правил синтаксиса Ada вы можете воспользоваться некоторыми
дополнительными настройками. Для включения какой-либо возможности следует
присвоить соответствующей переменной какое-либо значение, например:
>
   let ada_standard_types = 1

Для отключения возможности следует удалить соответствующую переменную с
помощью ":unlet". Например:
>
   unlet ada_standard_types = 1

Вы можете просто использовать ":" для ввода этих команд в командной строке,
чтобы временно назначить соответствующие переменные перед загрузкой файла с
исходным кодом на языке Ada. Чтобы сделать эти настройки постоянными,
используйте команды "let" без двоеточия в файле "~/.vimrc".

Правила подсветки синтаксиса используют следующие возможности:

Переменная		 Действие	~
ada_standard_types	 Подсвечивать типы в пакете Standard 
			    (например, "Float")
ada_space_errors	 Подсвечивать ошибки с лишними пробелами...
ada_no_trail_space_error   но пропускать пробелы на хвосте строки
ada_no_tab_space_error	   но пропускать символы табуляции после пробелов
ada_withuse_ordinary	 Показывать "with" и "use" как обычные ключевые слова
			   (при использовании в качестве ссылки на другие 
			   блоки компиляции они обычно подсвечиваются особым
			   образом)
ada_begin_preproc	 Показывать все begin-подобные ключевые слова с
                           использованием подсветки команд препроцессора C.

Даже на медленных (90MHz) компьютерах подсветка синтаксиса для Ada работает
быстро, но если вы считаете, что производительность сильно снижается, то
попробуйте включить ada_withuse_ordinary.


ANT				        *ant.vim* *ant-syntax* *ant-синтаксис*

Сценарий правил синтаксиса для ant по умолчанию включает правила для
javascript и python. Правила подсветки для других сценарных языков могут быть
включены с помощью функции AntSyntaxScript(), которая принимает в качестве
первого параметра имя соответствующего атрибута тэга, а в качестве второго
параметра имя файла сценария правил синтаксиса. Например:
>
	:call AntSyntaxScript('perl', 'perl.vim')

Эта команда включает подсветку синтаксиса для языка perl в следующем коде ant:
>
	<script language = 'perl'><![CDATA[
	    # этот фрагмент подсвечивается в соответствии с правилами perl
	]]></script>

См. в разделе |свой_файл_синтаксиса-дополнение| информацию о постоянной
установке правил подсветки синтаксиса для сценарных языков.


APACHE			       *apache.vim* *apache-syntax* *apache-синтаксис*

Сценарий правил подсветки синтаксиса для конфигурационных файлов сервера
Apache можно настроить под различные версии сервера. По умолчанию используется
версия 1.3.x. Чтобы изменить настройки версии Apache, присвойте
соответствующее значение переменной "apache_version". Например:
>
	:let apache_version = "2.0"
<

		       *asm.vim* *asmh8300.vim* *nasm.vim* *masm.vim* *asm68k*
                    *asm-syntax* *asmh8300-syntax* *nasm-syntax* *masm-syntax*
АССЕМБЛЕР      *asm68k-syntax* *fasm.vim* *asm-синтаксис* *asmh8300-синтаксис*
		          *nasm-синтаксис* *masm-синтаксис* *asm68k-синтаксис*

Файлы с расширением "*.i" могут содержать код на языке ассемблер или
Progress. Если автоматическое определение не работает на вашей системе, либо
вы не сталкиваетесь с редактированием файлов на Progress, то вы можете
воспользоваться следующей командой в файле vimrc:
>
   :let filetype_i = "asm"
   
Вы можете заменить "asm" на тот тип ассемблера, который вы используете.

Одно и тоже расширение в имени файла используется самыми разными вариантами
языка ассемблер. Поэтому вам потребуется назначить необходимый тип вручную,
либо добавить в текст файла с исходным кодом строку, которую может распознать
Vim. На данный момент в поставку включены следующие файлы:

	asm		Ассемблер GNU (по умолчанию)
	asm68k		Ассемблер Motorola 680x0
	asmh8300	Ассемблер GNU для Hitachi H-8300
	ia64		Ассемблер Intel Itanium 64
	fasm		Ассемблер Flat (http://flatassembler.net)
	masm		Ассемблер Microsoft (возможно, работает со всеми
			  ассемблерами для 80x86)
	nasm		Ассемблер Netwide
	tasm		Турбо-ассемблер (с кодами операций 80x86 вплоть до
	                  Pentium, включая MMX)
	pic		Ассемблер PIC (на данный момент для PIC16F84)

Наиболее гибким решением является добавление строки в файл с кодом на языке
ассемблера, содержащую команду вроде:
>
	:asmsyntax=nasm
	
Вы можете заменить "nasm" именем соответствующего типа ассемблера. Эта строка
должна быть одной из пяти первых строк файла.

Тип синтаксиса может быть всегда переопределён для отдельного буфера путём
назначения переменной b:asmsyntax:
>
	:let b:asmsyntax=nasm

Если переменной b:asmsyntax не назначено какое-либо значение вручную или
автоматически, то используется значение глобальной переменной asmsyntax.
Значение этой переменной может рассматриваться как настройка типа ассемблера
по умолчанию:
>
	:let asmsyntax=nasm

В крайнем случае, если вышеуказанные определения отсутствуют, используются
правила подсветки синтаксиса для "asm".

Дополнительные настройки для ассемблера Netwide (nasm.vim) ~

Чтобы включить особенность, выполните команду:
>
	:let   {variable}=1|set syntax=nasm
	
Чтобы отключить особенность, выполните команду:
>
	:unlet {variable}  |set syntax=nasm

Переменная 		Подсветка ~
nasm_loose_syntax	Синтаксис, разрешённый неофициальным парсером кода
			  не рассматривается как ошибка в коде (Error).
			  Настройка зависит от парсера и не рекомендуется к
			  использованию.
nasm_ctx_outside_macro	Контекст вне макроса не считается ошибкой в коде
                          (Error)
nasm_no_warn		Не рассматривать потенциально рискованный синтаксис
			  как группу ToDo


                                              *aspperl-syntax* *aspvbs-syntax*
ASPPERL и ASPVBS                        *aspperl-синтаксис* *aspvbs-синтаксис*

Файлы с расширениями *.asp и *.asa могут содержать сценарии как на языке
Perl, так и на языке Visual Basic. Поскольку определить фактический язык в
данном случае не так просто, вы можете использовать две глобальные переменные,
чтобы указать Vim'у какой язык следует использовать. Для сценария на языке
Perl:
>
	:let g:filetype_asa = "aspperl"
	:let g:filetype_asp = "aspperl"
	
Для языка Visual Basic: 
>
	:let g:filetype_asa = "aspvbs"
	:let g:filetype_asp = "aspvbs"
<

				*basic.vim* *vb.vim* *basic-syntax* *vb-syntax*
BASIC				               *basic-синтаксис* *vb-синтаксис*

Как Visual Basic, так  "обычный" Basic используют расширение ".bas". Для
определения правил синтаксиса Vim проверяет наличие строки "VB_Name" в первых
пяти строках файла. Если эта строка не найдена, то тип файла определяется как
"basic", в противном случае тип файла определяется как "vb". Файлы с
расширением ".frm" всегда считаются файлами с кодом Visual Basic.


C					      *c.vim* *c-syntax* *c-синтаксис*

Некоторые особенности подсветки синтаксиса в коде на языке C являются
дополнительными. Для их включения следует присвоить любое значение
соответствующей переменной. Например:
>
	:let c_comment_strings=1
	
Для отключения раннее включённых таким образом особенностей следует
воспользоваться командой ":unlet". Например:
>
	:unlet c_comment_strings

Переменная		Подсветка ~
c_gnu			элементы, встречающиеся только в GNU gcc
c_comment_strings	строки и числа внутри комментариев
c_space_errors		пробелы на хвосте строк и пробелы перед символом <Tab>
c_no_trail_space_error	  ...только пробелы перед <Tab>
c_no_tab_space_error	  ...только пробелы на хвосте строк
c_no_bracket_error	не подсвечивать {}; внутри [] как ошибку синтаксиса
c_no_ansi		не подсвечивать стандартные типы и константы ANSI
c_ansi_typedefs		  ...не подсвечивать только стандартные константы ANSI
c_ansi_constants	  ...не подсвечивать только стандартные типы ANSI
c_no_utf		не подсвечивать \u и \U в строках
c_syntax_for_h		использовать синтаксис C для файлов *.h вместо
                          синтаксиса C++
c_no_if0		не подсвечивать блоки "#if 0" как комментарии
c_no_cformat		не подсвечивать элементы формата % в строках
c_no_c99		не подсвечивать стандартные элементы C99

Если вы замечаете ошибки в подсветке при выполнении прокрутки назад, которые
исправляются при обновлении экрана по команде CTRL-L, попытайтесь увеличить
значение переменной "c_minlines":
>
	:let c_minlines = 100
	
Это позволяет начинать синхронизацию подсветки синтаксиса за 100 строк до
первой отображаемой строки. По умолчанию используется значение 50 (15 при
использовании c_no_if0). При использовании большого значения этой переменной
обновление экрана может происходить более медленно.

При использовании подсветки в комментарии "#if 0" / "#endif" обратите
внимание, что это работает только в том случае, если строка "#if 0" попадает 
в "c_minlines" строк от первой строки в окне. Если вы используете длинную
конструкцию "#if 0", то она может подсвечиваться неправильно.

Чтобы находить соответствия дополнительным элементам внутри комментариев,
используйте кластер cCommentGroup. Например:
>
   :au Syntax c call MyCadd()
   :function MyCadd()
   :  syn keyword cMyItem contained Ni
   :  syn cluster cCommentGroup add=cMyItem
   :  hi link cMyItem Title
   :endfun

Константы ANSI будут подсвечиваться с помощью группы "cConstant". Сюда
относятся такие слова, как "NULL", "SIG_IGN" и другие, но не относится "TRUE",
поскольку эта константа не входит в стандарт ANSI. Если вас это смущает, то вы
можете убрать подсветку для группы cConstant:
>
	:hi link cConstant NONE

Если в вашем исходном коде '{' и '}' подсвечиваются как синтаксическая ошибка,
хотя скобки находятся на своём месте и этого не должно происходить, отключите
подсветку для групп cErrInParen и cErrInBracket.

Если вы хотите использовать в файлах с исходным кодом на языке C складки, то
вам следует добавить в сценарий, помещённый в каталоге "after" по пути,
указанному в значении опции 'runtimepath', следующие строки:
>
    syn region myFold start="{" end="}" transparent fold
    syn sync fromstart
    set foldmethod=syntax

В Unix это может быть, например, файл ~/.vim/after/syntax/c.vim.


CHILL			          *chill.vim* *chill-syntax* *chill-синтаксис*

Подсветка синтаксиса для Chill похожа на C. О доступных настройках читайте в
разделе |c.vim|. Кроме того, имеются следующие дополнительные настройки:

chill_syntax_for_h	Использовать синтаксис Ch для файлов *.h, 
			  вместо синтаксиса C или C++
chill_space_errors	как c_space_errors
chill_comment_string	как c_comment_strings
chill_minlines		как c_minlines


                                            *changelog.vim* *changelog-syntax*
CHANGELOG (Журнал изменений)                             *changelog-синтаксис*

В файлах журнала изменений (ChangeLog) поддерживается подсветка пробелов в
начале строки. Если вам это не нравится, добавьте к файлу .vimrc следующую
строку:
>
	let g:changelog_spacing_errors = 0
	
Эта настройка вступит в силу при редактировании следующего файла с журналом
изменений. Вы также можете ввести такую настройку для отдельного буфера с
помощью переменной "b:changelog_spacing_errors" (она должна быть изменена до
загрузки сценария подсветки синтаксиса).

Вы можете изменить используемую подсветку, например помечать пробелы как
ошибку:
>
	:hi link ChangelogError Error
	
Либо отключить ту или иную подсветку:
>
	:hi link ChangelogError NONE
	
Эта настройка вступает в силу немедленно.


COBOL			          *cobol.vim* *cobol-syntax* *cobol-синтаксис*

Применение подсветка синтаксиса для COBOL предъявляет разные требования для
старого исходного кода и кода, который написан в современных условиях. Это
связано с различиями между форматом кода при поддержке и разработке, а также с
рядом других факторов. Чтобы использовать подсветку синтаксиса для старого
исходного кода, добавьте в .vimrc следующую строку:
>
	:let cobol_legacy_code = 1

Чтобы отключить использование подсветки синтаксиса в режиме старого исходного
кода, используйте команду:
>
	:unlet cobol_legacy_code


COLD FUSION	   *coldfusion.vim* *coldfusion-syntax* *coldfusion-синтаксис*

В ColdFusion используется собственная версия комментариев HTML. Для включения
подсветки комментариев ColdFusion добавьте в файл сценария настроек следующую
строку:
>
	:let html_wrong_comments = 1

Сценарий подсветки синтаксиса для ColdFusion основан на сценарии подсветки
синтаксиса HTML.


CSH			                *csh.vim* *csh-syntax* *csh-синтаксис*

Говоря о правилах синтаксиса для оболочки "csh", заметим, что на некоторых
системах на самом деле используется оболочка tcsh. Определить какая именно
оболочка используется очень сложно. На некоторых системах имеется
символическая связь между /bin/csh и /bin/tcsh, что делает распознавание
конкретной оболочки практически невозможным. В том случае, когда Vim делает
неправильное предположение, вы можете его поправить с помощью переменной
"filetype_csh". Например, для csh:
>
	:let filetype_csh = "csh"

для tcsh:
>
	:let filetype_csh = "tcsh"

Тип файла для всех сценарии, имеющие расширение tcsh или стандартное для tcsh
имя файла (.tcshrc, tcsh.tcshrc, tcsh.login) будут определен как tcsh. Все
остальные tcsh/csh сценарии будут определяться как tcsh, КРОМЕ случая, когда
определена переменная "filetype_csh". Если существует переменная
"filetype_csh", то тип файла назначается в соответствии со значением этой
переменной.


CYNLIB		               *cynlib.vim* *cynlib-syntax* *cynlib_синтаксис*

Файлы Cynlib это файлы C++, которые используют библиотеку Cynlib, которая
позволяет выполнять моделирование и симуляцию различных устройств с помощью
C++. Обычно файлы Cynlib имеют расширение .cc или .cpp, что делает крайне
сложным их отличие от обычных файлов С++. Поэтому, если вы хотите включить
подсветку синтаксиса Cynlib для файлов .cc, вам следует добавить в .vimrc
следующую строку:
>
	:let cynlib_cyntax_for_cc=1

Аналогично, для файлов cpp (это расширение как правило используется только в
Windows):
>
	:let cynlib_cyntax_for_cpp=1

Чтобы отключить подсветку синтаксиса Cynlib, используйте следующие команды:
>
	:unlet cynlib_cyntax_for_cc
	:unlet cynlib_cyntax_for_cpp
<

CWEB			             *cweb.vim* *cweb-syntax* *cweb-синтаксис*

Файлы с расширением "*.w" могут быть как файлами Progress, так и cweb. Если
автоматическое распознавание не приводит к нужному результату, либо вы не
сталкиваетесь в своей работе с файлами Progress, добавьте в файл .vimrc
следующую строку: 
>
   :let filetype_w = "cweb"


DESKTOP		            *desktop.vim* *desktop-syntax* *desktop-синтаксис*

Этот сценарий подсветки в основном используется при работе с файлами .desktop
и .directory, отвечающим стандарту от freedesktop.org 
(см. http://pdx.freedesktop.org/Standards/). Следует, однако, заметить, что
пока никто полностью не реализовал этот стандарт. Таким образом, этот сценарий
может использоваться для подсветки почти всех настроечных файлов для Unix. Вы
можете принудительно включить строгое соответствие стандарту, поместив в vimrc
следующую строку:
>
	:let enforce_freedesktop_standard = 1


DIRCOLORS	      *dircolors.vim* *dircolors-syntax* *dircolors-синтаксис*

Сценарий с правилами подсветки синтаксиса для файлов конфигурации dircolors
использует специальную настройку для обеспечения совместимости с версией этой
программы, которая поставляется в Slackware GNU/Linux. При помощи этой
настройки добавляется несколько дополнительных ключевых слов, которые
игнорируются в других версиях. В системах Slackware, однако, эти ключевые
слова допускаются и используются при работе программы. Чтобы включить ключевые
слова, которые используются в Slackware, добавьте в сценарий запуска Vim
следующую строку:
>
	let dircolors_is_slackware = 1


DOCBOOK			*docbk.vim* *docbk-syntax* *docbook* *docbk-синтаксис*
DOCBOOK	XML		 *docbkxml.vim* *docbkxml-syntax* *docbkxml-синтаксис*
DOCBOOK	SGML	      *docbksgml.vim* *docbksgml-syntax* *docbksgml-синтаксис*

Существует два вида файлов DocBook: SGML и XML. Чтобы указать, какой именно
тип используется в данном файле, следует присвоить соответствующее значение
переменной "b:docbk_type". Если Vim сможет сам распознать разновидность файла
DocBook, то это будет сделано автоматически. В том случае, если автоматическое
распознавание не срабатывает, по умолчанию принимается, что Vim имеет дело с
файлом XML.

Вы можете изменить значение этой переменной вручную:
>
	:let docbk_type = "sgml"
или: >
	:let docbk_type = "xml"

Заметим, что это необходимо сделать до загрузки сценария с правилами подсветки
синтаксиса, что может вызывать некоторую трудность. Гораздо проще назначить
тип файла "docbkxml" или "docbksgml":
>
	:set filetype=docbksgml
или: >
	:set filetype=docbkxml
<

                                              *dosbatch.vim* *dosbatch-syntax*
DOSBATCH (КОМАНДНЫЕ ФАЙЛЫ DOS)	                          *dosbatch-синтаксис*

Сценарий подсветки командных файлов DOS позволяет включать использование
дополнительных особенностей командного интерпретатора, которые появились в
Windows 2000. Управление этой настройкой осуществляется при помощи переменной
dosbatch_cmdextversion. Значение этой переменной при работе с командными
файлами Windows NT должно быть равно 1, а при работе с командными файлами
Windows 2000 -- 2. Например,
>
  :let dosbatch_cmdextversion = 1

Если эта переменная не определена, то её значение по умолчанию принимается
равным 2, чтобы обеспечить поддержку Windows 2000.


DTD			                *dtd.vim* *dtd-syntax* *dtd-синтаксис*

Подсветка синтаксиса для DTD по умолчанию чувствительна к регистру символов.
Чтобы отключить регистрозависимую подсветку, добавьте в сценарий запуска
следующую строку:
>
	:let dtd_ignore_case=1

Сценарий подсветки синтаксиса DTD выполняет подсветку неизвестных тэгов как
ошибки. Если вас это раздражает, то можно отключить эту особенность при помощи
следующей строки:
>
	:let dtd_no_tag_errors=1

Эта настройка должна быть выполнена до выполнения сценария dtd.vim.

Имена параметрических сущностей подсвечиваются при определении с
использованием группы подсветки 'Type', а также при помощи группы 'Comment'
для символов пунктуации и '%'. При использовании параметрических сущностей в
документе их имена подсвечиваются с использованием группы подсветки
'Constant', а для разделителей % и ; используется группа подсветки 'Type'. Вы
можете отключить это при помощи следующей команды:
>
	:let dtd_no_param_entities=1

Сценарий подсветки синтаксиса DTD также включается в сценарий xml.vim для
подсветки включённых в XML-документы dtd.


EIFFEL			       *eiffel.vim* *eiffel-syntax* *eiffel-синтаксис*

Несмотря на то, что в Eiffel используется регистронезависимый синтаксис,
хорошим стилем считается аккуратное использование регистра символов, и
сценарий подсветки синтаксиса для Vim поощряет внимательное отношение к
регистру символов. Это также позволяет подсвечивать имена классов по разному.
Если вы хотите отключить регистрозависимую подсветку синтаксиса, то добавьте
к сценарию настроек следующую строку:
>
	:let eiffel_ignore_case=1

Даже при использовании указанной переменной регистр символов имеет значение
для имён классов и отметок TODO ("надо сделать") в комментариях.

С другой стороны, вы можете включить более строгий режим проверок с помощью
следующих команд:
>
	:let eiffel_strict=1
	:let eiffel_pedantic=1

При использовании переменной eiffel_strict будет отслеживаться использование
неправильного регистра символов в пяти предопределённых ключевых словах:
"Current", "Void", "Result", "Precursor" и "NONE", чтоб предупредить их
случайное использование в качестве имени особенности или класса.

Использование переменной eiffel_pedantic позволяет включить режим строгого
соответствия стилистическому руководству Eiffel (например, будет отслеживаться
сочетание символов в верхнем и нижнем регистрах, устаревшие способы
использования верхнего регистра символов).

Если вы хотите использовать варианты слов "Current", "Void", "Result" и
"Precursor", записанные в нижнем регистре, то для этой цели имеется другая
переменная:
>
	:let eiffel_lower_case_predef=1

Лучше всего воспользоваться этой переменной, чем полностью отключать
регистрозависимую подсветку.

Поддержка нового синтаксиса создания, предложенного ISE и экспериментально
поддерживаемого некоторыми компиляторами, может быть включена с помощью
команды:
>
	:let eiffel_ise=1

Наконец, некоторые поставщики поддерживают шестнадцатеричные константы. Их
поддержка включается путём добавления строки
>
	:let eiffel_hex_constants=1

в файл настроек.


ERLANG			       *erlang.vim* *erlang-syntax* *erlang-синтаксис*

Сценарий подсветки синтаксиса erlang используется для языка Erlang (ERicsson
LANGuage, язык Ericson). Синтаксис Erlang чувствителен к регистру символов и
использует в качестве расширения по умолчанию ".erl".

Если вы хотите отключить подсветку ключевых слов, поместите в файл .vimrc
следующую строку:
>
	:let erlang_keywords = 1
	
Чтобы отключить подсветку встроенных функций, поместите в файл .vimrc
следующую строку:
>
	:let erlang_functions = 1

Чтобы отключить подсветку специальных символов, поместите в файл .vimrc
следующую строку:
>
	:let erlang_characters = 1


FORM			             *form.vim* *form-syntax* *form-синтаксис*

Подсветка синтаксических элементов в файлах FORM использует основные режимы
Conditional, Number, Statement, Comment, PreProc, Type и String в соответствии
со стандартом языка, описанным в книге J.A.M. Vermaseren 'Symbolic
Manipulation with FORM', CAN, Netherlands, 1991

При внесении изменений в определённые по умолчанию цвета вам потребуется
переопределить следующие синтаксические группы:

    - formConditional
    - formNumber
    - formStatement
    - formHeaderStatement
    - formComment
    - formPreProc
    - formDirective
    - formType
    - formString

Обратите внимание, что сценарий подсветки синтаксиса form.vim помещает по
умолчанию команды препроцессора FORM и директивы в одну синтаксическую группу.

При использовании подсветки синтаксиса для FORM также доступен режим
улучшенной подсветки, который позволяет отличать выражения в заголовках и в
теле программы на FORM. Для включения этого режима следует определить в файле
vimrc следующую переменную:
>
	:let form_enhanced_color=1

Режим улучшенной подсветки также использует дополнительные возможности работы
с цветом, доступные в gvim на тёмном экране. В частности, предложения
подсвечиваются светло-жёлтым (LightYellow) вместо жёлтого (Yellow), а условные
выражения подсвечиваются голубым (LightBlue), чтобы сделать их более
заметными.


FORTRAN		            *fortran.vim* *fortran-syntax* *fortran-синтаксис*

Подсветка по умолчанию и диалекты ~

По умолчанию используется подсветка, соответствующая грамматике языка f95
(Fortran 95). Этот выбор скорее всего подходит большинству пользователей,
поскольку синтаксис Fortran 95 является надмножеством синтаксиса языка 
Fortran 90 и почти является надмножеством языка Fortran 77.

Формат исходного кода на языке Fortran ~

Исходный код на языке Fortran 9x может быть в жёстком или свободном формате.
Обратите внимание, что подсветка синтаксиса будет работать неправильно, если
соответствующий формат задан неверно.

При создании нового файла с исходным кодом на языке fortran сценарий подсветки
синтаксиса по умолчанию полагает, что используется жёсткий формат исходного
кода. Если вы всегда используете свободный формат, то поместите в .vimrc
команду
>
    :let fortran_free_source=1
    
до того, как будет выполнена команда :syntax on. С другой стороны, если вы
используете только жёсткий формат исходного кода fortran, то вы можете
поместить в файл .vimrc команду
>
    :let fortran_fixed_source=1

перед выполнением команды :syntax on.

Если формат исходного кода зависит от расширения файла, то удобнее всего
назначать переменную fortran_free_source в сценарии типа файла. Более
подробная информация о сценариях типа файла приводится в разделе
|написание_модулей_типа_файла|. Например, если все файлы с расширением .f90
написаны с использованием свободного формата исходного кода, в то время как
остальные файлы на Фортране используют жёсткий формат, то можно добавить в
сценарий типа файла следующие команды:
>
    let s:extfname = expand("%:e")
    if s:extfname ==? "f90"
	let fortran_free_source=1
	unlet! fortran_fixed_source
    else
	let fortran_fixed_source=1
	unlet! fortran_free_source
    endif

Обратите внимание, что это будет работать только в том случае, если команда
"filetype plugin indent on" предшествует в сценарии .vimrc команде 
"syntax on".

При редактировании существующих файлов на Фортране сценарий подсветки
синтаксиса будет считать, что файл написан в свободном формате, если
определена переменная fortran_free_source, или в жёстком формате, если
определена переменная fortran_fixed_source. Если не определена ни одна из
указанных переменных, то сценарий подсветки синтаксиса пытается определить
используемый формат исходного кода путём анализа первых пяти колонок первых 25
строк файла. Если признаки свободного формата не обнаружены, то считается, что
файл использует жёсткий формат. Такой алгоритм должен работать в большинстве
случаев. В то же время, если, например, файл начинается с 25 и более
строк полнострочных комментариев, сценарий может неправильно решить, что
используется жёсткий формат исходного кода Фортран. В этом случае достаточно
просто добавить какое-нибудь предложение на Фортране, не являющееся
комментарием и начинающиеся в первых пяти колонках первых 25 строк, и
перезагрузить файл (:e!) после его сохранения (:w).

Символы табуляции в исходном коде Фортран ~

Символы табуляции не признаются стандартами Фортрана. Использование символов
табуляции в коде, применяющем жёсткий формат, не рекомендуется, поскольку
жёсткий формат требует строго заданных границ колонок. Поэтому, символы
табуляции отмечаются подсветкой как ошибки в синтаксисе. Тем не менее,
некоторым программистам нравится использовать символы табуляции. Если в вашем
файле исходного кода на Фортране используются символы табуляции, то вы можете
назначить переменную fortran_have_tabs в файле .vimrc, например с помощью
команды
>
    :let fortran_have_tabs=1

которую следует поместить до выполнения команды :syntax on. К сожалению,
использование символов табуляции приводит к тому, что сценарий подсветки
синтаксиса для языка Фортран будет не в состоянии определить неправильные
поля.

Складки в файлах Фортран, основанные на правилах синтаксиса ~

Если вы хотите использовать foldmethod=syntax, то прежде всего вам необходимо
включить переменную fortran_fold при помощи команды
>
    :let fortran_fold=1

чтобы сценарий подсветки синтаксиса мог определить области складок для
различных программных блоков, таких как основная программа, начинающаяся с
предложения program, подпрограммы блоковых данных, блоки интерфейса и модули.
Если вы также включите переменную fortran_fold_conditionals по команде
>
    :let fortran_fold_conditionals=1

то соответствующие складки будут также определены для циклов do, блоков if и
конструкций select case. Кроме того, если вы включите переменную
fortran_fold_multilinecomments по команде
>
    :let fortran_fold_multilinecomments=1

то области складок будут также определены для трёх и более последовательных
строк с комментариями. Заметим, что в больших файлах определение областей для
складок может занять некоторое время.

При включённой переменной fortran_fold и возможно включённых переменных
fortran_fold_conditionals и/или fortran_fold_multilinecomments Vim будет
выполнять автоматическую разметку складок при использовании foldmethod=syntax.
Комментарии и пустые строки, помещённые между двумя блоками программы не
помещаются в складку, поскольку они рассматриваются как не принадлежащие ни к
одному из программных блоков.

Более точный синтаксис для Фортрана ~

Если вы включите переменную fortran_more_precise по команде
>
    :let fortran_more_precise=1
    
то подсветка синтаксиса будет выполняться более медленно, но зато более точно.
В частности, будут распознаваться метки предложений, используемые в do, goto и
арифметических конструкциях if, а также имена конструкций в конце do, if,
select и forall.

Нестандартные диалекты Фортрана ~

Сценарий подсветки синтаксиса поддерживает пять диалектов Фортрана: f95, f90,
f77, подмножество Lahey elf90 и подмножество F Imagine1.

Если вы пользуетесь f77 с расширениями, вроде циклов do/enddo, do/while и
свободным форматом исходного кода, которые поддерживаются большинством
компиляторов f77, в том числе g77 (GNU Fortran), то вас скорее всего
удовлетворят используемые по умолчанию настройки. Если вы используете жёсткий
формат исходного кода без расширений, без использования свободного формата
исходного кода и даже без расширений MIL STD 1753, то при назначении диалекта
f77 вы получите дополнительные преимущества: имена вроде SUM будут
распознаваться как имена пользовательских переменных и не будут подсвечиваться
как имена встроенных функций f9x, устаревшие конструкции вроде предложений
ASSIGN не будут подсвечиваться как элементы TODO ("надо сделать"), а исходный
код будет всегда восприниматься как написанный в жёстком формате.

Если вы используете elf90 или F, то преимущества от принудительного назначения
диалекта заключаются в следующем: не включённые в соответствующий диалект
особенности f90 будут подсвечиваться как элементы TODO, а исходный код будет
автоматически восприниматься как написанный в свободном формате, как того
требует синтаксис этих диалектов.

Диалект может быть назначен при помощи переменной fortran_dialect. Значение
переменной fortran_dialect должно быть одним из следующих: "f95", "f90",
"f77", "elf" или "F" (соблюдайте регистр символов!). Неправильные значения
переменной fortran_dialect игнорируются.

Если во всех ваших файлах на языке Фортран используется один и тот же диалект,
то имеет смысл назначить переменную fortran_dialect в сценарии .vimrc (до
выполнения команды "syntax on"). Если диалект зависит от расширения файла, то
удобнее всего поместить команду назначения диалекта в сценарии модуля типа
файла. Более подробные сведения об этих сценариях можно почерпнуть в разделе
|написание_модулей_типа_файла|. Например, если все файлы на языке Фортран с
расширением .f90  написаны на диалекте elf, то в модуле типа файла может
содержаться такой код:
>
    let s:extfname = expand("%:e")
    if s:extfname ==? "f90"
	let fortran_dialect="elf"
    else
	unlet! fortran_dialect
    endif

Заметим, что этот метод будет работать только в том случае, если команда
"filetype plugin indent on" предшествует команде "syntax on" в файле .vimrc.

Если расширение имени файла не определяет диалект единственным образом, то вам
может потребоваться более тонкий контроль за используемым диалекта. Вы
можете переопределить используемый по умолчанию диалект для конкретных
файлов путём включения директивы "fortran_dialect=xx" (где xx это f77 или elf
или F или f90 или f95) в одной из трёх первых строк файла. Например, если
часть старых файлов .f на вашей машине использует расширенный f77, но в новых
файлах используется F, то вы можете включить в одну из первых трёх строк таких
файлов комментарий языка Фортран в формате
>
  ! fortran_dialect=F

что позволяет использовать диалект F. F имеет приоритет перед elf, если
используются обе директивы одновременно.

Ограничения ~

Проверка скобок не отслеживает недостаточное количество закрывающих скобок. Не
распознаются строки Голлерита. Некоторые ключевые слова могут подсвечиваться
неправильно, поскольку в Fortran90 отсутствуют зарезервированные ключевые
слова.

Дополнительная информация об использовании редактора для правки кода на языке
Фортран даётся в разделах |fortran-отступы| и |fortran-модуль|.


ФАЙЛЫ НАСТРОЕК FVWM                  *fvwm.vim* *fvwm-syntax* *fvwm-синтаксис*

Чтобы Vim мог распознавать файлы с настройками Fvwm, имена которых не
соответствуют шаблонам *fvwmrc* и *fvwm2rc* , вам потребуется добавить
необходимые шаблоны в файл myfiletypes.vim. Для этих шаблонов следует
определить переменную "b:fvwm_version", значение которой должно
соответствовать номеру основной версии Fvwm, а также назначить fvwm в качестве
значения опции 'filetype'.

Например, чтобы Vim распознавал все файлы в каталоге /etc/X11/fvwm2/ как
файлы с настройками Fvwm2, добавьте такую строку:
>
  :au! BufNewFile,BufRead /etc/X11/fvwm2/*  let b:fvwm_version = 2 |
					 \ set filetype=fvwm

Если вы хотите, чтобы Vim подсвечивал все допустимые имена цветов, то вам
нужно подсказать ему, где находится файл с перечнем цветов (rgb.txt). Для
этого следует назначить путь к этому файлу переменной "rgb_file". Например,
если на вашей системе база данных цветов находится в каталоге
/usr/X11/lib/X11/, то вам нужно добавить в файл .vimrc следующую строку:
>
	:let rgb_file = "/usr/X11/lib/X11/rgb.txt"


GSP							             *gsp.vim*

Основной стиль для подсветки страниц GSP определён в сценарии |html.vim|, 
а подсветка кода на языке Java (в тэгах java и в строках внутри обратных
одинарных кавычек) определена в сценарии |java.vim|. Группы HTML

    htmlString
    htmlValue
    htmlEndTag
    htmlTag
    htmlTagN

определённые в сценарии |html.vim| переопределены с тем, чтобы обеспечить
включение и подсветку внутристрочного кода на языке Java.

Подсветка внутристрочного кода на языке Java должна работать в большинстве
случаев. Если в каком-то особом месте код Java не подсвечивается как таковой,
то вы можете добавить соответствующую группу HTML к списку групп, где
выполняется подсветка кода Java. Для этого достаточно скопировать
соответствующую строку из сценария |html.vim| и добавить gspJava к параметру
contains.

Обратные кавычки для внутристрочного кода Java подсвечиваются по правилам
группы htmlError, чтобы их было легче увидеть.


GROFF				  *groff.vim* *groff-syntax* *groff-синтаксис*

Сценарий подсветки синтаксиса groff является обёрткой для сценария
|nroff.vim|. Соответствующие замечания по настройке и примеры использования
приводятся ниже в разделе |nroff.vim|. Обёртка включает дополнительные
расширения для синтаксиса groff путём назначения типа файла из
|режимной_строки| или в личном файле определений типов файлов (см.
|filetype.txt|).


HASKELL	     *haskell.vim* *lhaskell.vim* *haskell-syntax* *haskell-синтаксис*

Сценарий подсветки синтаксиса для кода на языке Haskell поддерживает как
простой код Haskell, так и код Haskell с использованием грамотного
программирования, причём в последнем случае поддерживается как стиль Bird, 
так и стиль TeX. Подсветка синтаксиса Haskell также обеспечивает подсветку
команд препроцессора C.

Если вы хотите включить подсветку символов-разделителей (что полезно в тех
ситуациях, когда вы используете светлый фон), то добавьте к .vimrc строку:
>
	:let hs_highlight_delimiters = 1

Чтобы рассматривать True и False в качестве ключевых слов вместо обычных имён,
добавьте:
>
	:let hs_highlight_boolean = 1

Чтобы рассматривать имена примитивных типов в качестве ключевых слов:
>
	:let hs_highlight_types = 1

Наконец, чтобы рассматривать в качестве ключевых слов ещё больше относительно
общепринятых типов, добавьте строку:
>
	:let hs_highlight_more_types = 1
	
Чтобы подсвечивать имена отладочных функций, следует добавить в .vimrc строку:
>
	:let hs_highlight_debug = 1

Правила подсветки синтаксиса для языка Haskell также позволяют подсвечивать
команды препроцессора C и помечать строки, которые начинаются с #, но при этом
не являются правильными командами препроцессора как написанные с ошибкой. Это
может противоречить синтаксису Haskell для операторов, поскольку они могут
начинаться с символа #. Если вы хотите подсвечивать такие строки как
операторы, а не как ошибки, то добавьте в файл .vimrc следующую строку:
>
	:let hs_allow_hash_operator = 1

Подсветка синтаксиса для кода на Haskell с использованием грамотного
программирования пытается самостоятельно определить, содержит грамотный код
Haskell разметку TeX или нет, и в зависимости от этого может подсвечивать
конструкции TeX. Вы можете отменить автоматическое распознавание для всех
файлов Haskell с помощью следующих строк в файле .vimrc:
>
	:let lhs_markup = none

для отмены подсветки, или
>
	:let lhs_markup = tex
	
для принудительного включения подсветки TeX. Большей гибкости можно добиться с
помощью местного по отношению к буферу варианта этой переменной, например
>
	:let b:lhs_markup = tex
	
позволяет принудительно включить подсветку TeX для данного буфера. Такая
переменная должна быть назначена до включения подсветки синтаксиса в данном
буфере или перед загрузкой файла.


HTML			             *html.vim* *html-syntax* *html-синтаксис*

Подсветка синтаксиса для тэгов HTML работает следующим образом.

Разделители <> открывающих тэгов подсвечиваются иначе, чем разделители </>
закрывающих тэгов. Это сделано не случайно! Открывающие тэги подсвечиваются
цветом 'Function', а закрывающие тэги подсвечиваются цветом 'Type' (для
проверки конкретных значений используемых цветов на вашей системе 
см. syntax.vim).

Имена известных тэгов подсвечиваются так же, как и предложения на языке C.
Имена неизвестных тэгов подсвечиваются тем же цветом, что и <> или </>, в
зависимости от того, какой тэг используется, что позволяет легко обнаруживать
ошибки.

Обратите внимание, что вышесказанное также относится и к именам параметров
(атрибутов). Известные имена атрибутов подсвечиваются иначе, чем
неизвестные.

Некоторые тэги HTML используются для изменения отображения текста. Сценарий
подсветки синтаксиса html.vim отличает тэги <B>, <I>, <U>, <EM>, <STRONG>
(<EM> используется в качестве синонима <I>, а <STRONG> используется в
качестве синонима <B>), <H1> - <H6>, <HEAD>, <TITLE> и <A>, таким образом,
что отображение помещённого в эти тэги текста изменяется соответствующим
образом. (В случае тэга <A> отображение текста изменяется только в том случае,
если <A> используется для создания ссылки, т.е. включает атрибут href,
например: <A href="somefile.html">).

Если вы желаете изменить отображение такого текста в редакторе, то вам
потребуется переопределить несколько синтаксических групп:

    - htmlBold
    - htmlBoldUnderline
    - htmlBoldUnderlineItalic
    - htmlUnderline
    - htmlUnderlineItalic
    - htmlItalic
    - htmlTitle для заголовка страницы
    - htmlH1 - htmlH6 для подзаголовков

Чтобы указанные переопределения заработали, вам необходимо переопределить их
все (за исключением, может быть последних двух -- htmlTitle и htmlH[1-6] можно
не переопределить) и назначать в vimrc следующую переменную
>
	:let html_my_rendering=1

Это вызвано особым порядком, в котором файлы читаются при инициализации.

Пример такой специальной настройки можно посмотреть в файле mysyntax.vim,
который доступен по адресу http://www.fleiner.com/vim/download.html.

Вы также можете отключить особый режим отображения такого текста путём
добавления следующей строки в файл vimrc:
>
	:let html_no_rendering=1

Комментарии HTML имеют весьма необычный синтаксис (подробности 
см. в документации по HTML), сценарий подсветки синтаксиса будет подсвечивать
все ошибки в комментариях. Однако, если вам нравится использовать неправильный
стиль комментариев (т.е. начинать комментарии с последовательности <!-- и
заканчивать последовательностью --!>), то вы можете определить переменную
>
	:let html_wrong_comments=1

Код на JavaScript и Visual Basic, внедрённый в документы HTML подсвечивается
как 'Special', с использованием стандартных правил подсветки предложений,
комментариев, строк и других подобных элементов, принятых в других языках
программирования. Обратите внимание, что на данный момент поддерживается
только JavaScript и Visual Basic, другие сценарные языки пока не добавлены.

Сценарий также обеспечивает подсветку встроенных и внутристрочных каскадных
таблиц стилей (CSS).

Существует целый ряд препроцессорных языков для html. Сценарий html.vim был
написан таким образом, чтобы обеспечить простое использование правил подсветки
синтаксиса html в такого рода языках. Для этого достаточно добавить к сценарию
подсветки синтаксиса соответствующего языка следующие две строки (мы приводим
пример для ASP из сценария asp.vim):
>
    runtime! syntax/html.vim
    syn cluster htmlPreproc add=asp

Теперь от вас требуется только следить за тем, чтобы все области, которые
содержатся в препроцессорном языке, были добавлены в кластер htmlPreproc.


HTML/OS (от Aestiva)	       *htmlos.vim* *htmlos-syntax* *htmlos-синтаксис*

Подсветка синтаксиса для HTML/OS работает следующим образом.

Имена функций и переменных по умолчанию подсвечиваются одним и тем же цветом,
поскольку Vim не определяет различных цветов для функций и имён. Чтобы
изменить такое поведение (что рекомендуется, если вы хотите сделать имена
функций более различимыми с помощью другого цвета), вам потребуется добавить
файл ~/.vimrc следующую строку:
>
    :hi Function term=underline cterm=bold ctermfg=LightGray

Само собой, для ctermfg вы можете использовать любой другой цвет.

Другой проблемой, связанной с использованием HTML/OS является тот факт, что
для HTML/OS не существует какого-либо специального типа файла. Это можно
изменить после открытия файла путём включения синтаксиса HTML/OS вручную
следующим образом:
>
    :set syntax=htmlos

Наконец, следует заметить, что в качестве открывающих и закрывающих символов,
определяющих границы блока кода HTML/OS, могут быть использованы как << и >>,
так и [[ и ]].


IA64		     *ia64.vim* *intel-itanium* *ia64-syntax* *ia64-синтаксис*

Сценарий подсветки синтаксиса для языка ассемблер процессора Intel Itanium 64.
Подробнее о распознавании этого типа файла см. в разделе |asm.vim|.

Чтобы распознавать файлы *.inc в качестве файлов с исходным кодом на IA64,
добавьте к файлу .vimrc следующую строку:
>
    :let g:filetype_inc = "ia64"


INFORM			       *inform.vim* *inform-syntax* *inform-синтаксис*

Подсветка синтаксиса для программ на языке Inform включает символы,
предоставляемые библиотекой Inform Library, поскольку большинство программ
постоянно пользуется ими. Если вы не хотите, чтобы символы из Library
подсвечивались особым образом, добавьте в сценарий запуска Vim следующую
строку:
>
	:let inform_highlight_simple=1

По умолчанию предполагается, что программы Inform рассчитаны на Z-машины и
поэтому символы ассемблера Z-машины подсвечиваются соответствующим образом.
Если вы собираетесь исполнять программу в среде Glulx/Glk, то вам потребуется
добавить в сценарий запуска Vim следующую строку:
>
	:let inform_highlight_glulx=1

В этом случае будет выполняться подсветка кодов операций Glulx, а также будет
добавлена к списку системных функций, имена которых подсвечиваются особо,
функция glk().

Компилятор Inform помечает некоторые устаревшие ключевые слова как ошибки в
коде программы. Такие ключевые слова как правило подсвечиваются в виде ошибок
и в Vim. Чтобы предотвратить такую подсветку ошибок, вам следует добавить в
сценарий запуска Vim следующую строку:
>
	:let inform_suppress_obsolete=1

По умолчанию, подсветка языковых особенностей соответствует компилятору
Compiler версии 6.39 и библиотеке Library версии 6.11. Если вы применяете
более раннюю среду разработки Inform, то вы можете добавить следующую строку к
сценарию запуска Vim:
>
	:let inform_highlight_old=1


JAVA				     *java.vim* *java-syntax* *java-синтаксис*

Сценарий подсветки синтаксиса java.vim допускает ряд специальных настроек.

В Java 1.0.2 фигурные скобки не могли появляться внутри круглых скобок ни при
каких обстоятельствах, поэтому раннее это помечалось при подсветке как ошибка.
Поскольку в Java 1.1 это возможно (при использовании безымянных классов), это
более не рассматривается как ошибка. Если вас больше устраивает старый вариант
подсветки, поместите в сценарий загрузки Vim следующую строку:
>
	:let java_mark_braces_in_parens_as_errors=1

Все имена в java.lang.* всегда видимы во всех классах. Чтобы включить
подсветку таких имён используйте команду
>
	:let java_highlight_java_lang_ids=1

Вы также можете подсвечивать имена большинства стандартных пакетов java, если
установите сценарий javaid.vim, который доступен по адресу
http://www.fleiner.com/vim/download.html. Если вы хотите подсвечивать только
имена одного определённого пакета, например java.io, то используйте команду
>
	:let java_highlight_java_io=1
	
Список всех поддерживаемых пакетов приводится в файле javaid.vim.

Имена функций не подсвечиваются, поскольку способ обнаружения функций зависит
от того, как вы пишите код на языке Java. Сценарий подсветки синтаксиса
допускает два возможных способа подсветки функций:

Если вы записываете объявления функций таким образом, что они всегда
оформляются отступом с использованием символа табуляции, 8 пробелов или 2
пробелов, то вы можете применить команду
>
	:let java_highlight_functions="indent"

В то же время, если вы следуете принятым в Java соглашениям о наименовании
функций и классов (касающиеся использования регистра символов), то вы можете
применить команду
>
	:let java_highlight_functions="style"

Если эти настройки не работают в вашем случае, но вы желаете подсвечивать
объявления функций, то вам придётся создать собственные правила, изменив
определения в java.vim или создав собственный java.vim, включающий исходный
вариант с добавлением специального кода для подсветки функций.

В Java 1.1 функции System.out.println() и System.err.println() должны
применяться только для отладочных целей. По этой причине возможно применять
специальную подсветку отладочных предложений. Для этого необходимо добавить
следующее определение в сценарий запуска:
>
	:let java_highlight_debug=1

При этом отладочные предложения будут подсвечиваться с использованием группы
'Special'. Если вы предпочитаете использовать другую подсветку, то вам
потребуется определить новый режим подсветки для следующих групп:

    Debug, DebugSpecial, DebugString, DebugBoolean, DebugType,
    
которые применяются соответственно для подсветки самого предложения,
специальных символов в отладочных строках, строк, булевых констант и типов
(this, super). Мне нравится использовать для таких предложений особый цвет
фона.

Чтобы помочь в написании кода, который можно легко переносить между Java и
C++, все ключевые слова C++ помечаются как ошибка в коде программы Java. В то
же время, если вы постоянно их используете, то можете отменить такое поведение
путём определения следующей переменной в файле .vimrc:
>
	:let java_allow_cpp_keywords=1

Javadoc это программа, которая создаёт страницы HTML на основе специальных
комментариев в тексте программы на языке Java. В общем случае эти фрагменты
HTML подсвечиваются в соответствии с правилами подсветки HTML 
(см. |html.vim|). Вы даже можете добавлять в такой код фрагменты на javascript
и CSS (см. ниже). Вместе с тем имеются четыре важных отличия:

  1. Заголовок (все символы до первого символа '.', после которого следует
     пробел или вплоть до первого следующего символа '@') подсвечивается
     особым способом (для изменения цвета подсветки измените определение
     группы CommentTitle).
  2. Текст подсвечивается как 'Comment'.
  3. Комментарии HTML подсвечиваются как 'Special'.
  4. Специальные тэги javadoc (@see, @param, ...) подсвечиваются как
     специальные элементы, а их параметры (для тэгов @see, @param, @exception)
     подсвечиваются как группа Function.
 
Чтобы отключить эту особенность добавьте в сценарий загрузки следующую строку:
>
	:let java_ignore_javadoc=1

Если вы используете специальную подсветку комментариев javadoc, описанную
выше, то вы также можете включить специальную подсветку для сценариев на
javascript и visual basic и встроенных таблиц стилей CSS. Это имеет смысл
только в том случае, когда вы действительно используете комментарии javadoc,
включающие javascript или встроенный код CSS. Для этой цели применяются
следующие настройки:
>
	:let java_javascript=1
	:let java_css=1
	:let java_vb=1

Чтобы подсвечивать вложенные скобки различными цветами определите цвета для
javaParen, javaParen1 и javaParen2, например с помощью команды
>
	:hi link javaParen Comment

или
>
	:hi javaParen ctermfg=blue guifg=#0000ff

Если вы сталкиваетесь с нарушениями подсветки синтаксиса при прокрутке назад,
которые пропадают при обновлении окна по команде CTRL-L, попробуйте увеличить
значение внутренней переменной "java_minlines":
>
	:let java_minlines = 50

Это позволит выполнять синхронизацию синтаксиса за 50 строк до первой
отображаемой строки. По умолчанию используется значение 10. Использование
больших значений этой переменной может приводить к замедлению обновления
экрана.


LACE			             *lace.vim* *lace-syntax* *lace-синтаксис*

Lace (Language for Assembly of Classes in Eiffel, "язык для сборки классов
Eiffel") имеет регистронезависимый символ, однако руководство по стилю
программирования рекомендует следить за регистром символов. Если вы
предпочитаете регистронезависимую подсветку, то определите переменную Vim
"lace_case_insensitive" в сценарии загрузки:
>
	:let lace_case_insensitive=1


LEX				        *lex.vim* *lex-syntax* *lex-синтаксис*

Lex использует принудительную синхронизацию, поскольку разделители секций
"^%%$" не предлагают никаких подсказок о том, какая секция следует далее. Если
вы испытываете проблемы с синхронизацией (например, при работе с большими
файлами lex), то можете изменить значение параметра синхронизации:
>
	:syn sync minlines=300


LITE				     *lite.vim* *lite-syntax* *lite-синтаксис*

Подсветка синтаксиса для lite использует две настройки.

Если вы предпочитаете использовать в строках подсветку синтаксиса SQL, то
используйте команду
>
	:let lite_sql_query = 1

По умолчанию минимальное значение строк для синхронизации соответствует 100.
Если вы предпочитаете другое значение, то можете изменить переменную
"lite_minlines" в соответствии со своими требованиями. Например:
>
	:let lite_minlines = 200


LPC				        *lpc.vim* *lpc-syntax* *lpc-синтаксис*

LPC это простой язык с эффективным использованием памяти, его полное название:
Lars Pensj| C. Имена файлов с исходным кодом на языке LPC обычно имеют
расширение *.c. Поскольку распознавание файлов с такими именами как файлов на
языке LPC привело бы к недовольству пользователей, пишущих программы только
на C, то для использования синтаксиса LPC для таких файлов необходимо
назначить соответствующую переменную в сценарии .vimrc:
>
	:let lpc_syntax_for_c = 1

Если этот метод не срабатывает для некоторых файлов C или LPC, то вы можете
использовать режимную строку. Для файла LPC:
>
	// vim:set ft=lpc:

Для файла C, который ошибочно распознаётся как файл LPC:
>
	// vim:set ft=c:

Если вы не хотите назначать переменную lpc_syntax_for_c, то используйте
режимную строку во ВСЕХ файлах LPC.

LPC имеет несколько реализаций, мы намерены поддерживать наиболее
распространённые. По умолчанию используется синтаксис LPC для MudOS. При
использовании MudOS v22 и более ранних версий следует отключить чувствительные
модификаторы (это приведёт также к тому, что новые efun, появившиеся после
v22, будут считаться неправильными, так что не следует назначать эту
переменную при использовании последней версии MudOS):
>
	:let lpc_pre_v22 = 1

Для LpMud 3.2:
>
	:let lpc_compat_32 = 1

Для LPC4: 
>
	:let lpc_use_lpc4_syntax = 1

Для uLPC:

uLPC развился в Pike, так что вам лучше вместо этого сценария использовать
синтаксис Pike и использовать расширение *.pike в файлах с исходным кодом.


LUA			                *lua.vim* *lua-syntax* *lua-синтаксис*

Сценарий подсветки синтаксиса в поставке Vim может использоваться как для 
Lua 4.0, так и для Lua 5.0 (по умолчанию). Если вы пишете программы 
на Lua 4.0, то используйте команду
>
	:let lua_version = 4

Если переменная lua_version не существует, то её значение полагается равным 5.


MAIL								    *mail.vim*

Vim обеспечивает подсветку всех стандартных элементов сообщения электропочты
(заголовки, подпись, цитаты, а также адреса электропочты и URL). В
соответствии со стандартом, подпись начинается со строки, содержащей только
символы "--", за которыми могут следовать пробелы, и завершающейся символом
новой строки.

Vim считает цитатами текст, начинающийся с символов ']', '}', '|', '>' или
слова, за которым следует символ '>'. В то же время, Vim подсвечивает подписи
и заголовки в цитатах только в том случае, если цитируемый текст начинается с
символа '>' (за которым может следовать один пробел).

По умолчанию сценарий mail.vim синхронизируется за 100 строк до первой
отображаемой на экране строки. Если вы работаете на медленном компьютере и в
основном сталкиваетесь с электропочтой с короткими заголовками, то можете
использовать меньшую величину синхронизации:
>
    :let mail_minlines = 30


MAKE			             *make.vim* *make-syntax* *make-синтаксис*

В файлах makefile команды обычно подсвечиваются таким образом, чтобы было
легче обнаружить ошибки. В то же время, если это кажется вам слишком
"цветным", то вы можете отключить данную особенность с помощью команды
>
	:let make_no_commands = 1


MAPLE			          *maple.vim* *maple-syntax* *maple-синтаксис*

Maple V от Waterloo Maple Inc. поддерживает символьную алгебру. Язык
поддерживает множество пакетных функций, которые могут избирательно
загружаться пользователем. Стандартный набор пакетных функций, как он
поставляется в составе Maple V release 4 может подсвечиваться по желанию
пользователя. Чтобы подсвечивать все пакетные функции, можно добавить в .vimrc
команду
>
	:let mvpkg_all= 1

С другой стороны, пользователи могут выбрать любой набор из приведённой ниже
таблицы и включить его, назначив 1 соответствующей переменной в файле .vimrc
(это следует сделать до загрузки сценария $VIMRUNTIME/syntax/syntax.vim).

  Таблица переменных для выбора пакетных функций Maple V
>
  mv_DEtools	 mv_genfunc	mv_networks	mv_process
  mv_Galois	 mv_geometry	mv_numapprox	mv_simplex
  mv_GaussInt	 mv_grobner	mv_numtheory	mv_stats
  mv_LREtools	 mv_group	mv_orthopoly	mv_student
  mv_combinat	 mv_inttrans	mv_padic	mv_sumtools
  mv_combstruct mv_liesymm	mv_plots	mv_tensor
  mv_difforms	 mv_linalg	mv_plottools	mv_totorder
  mv_finance	 mv_logic	mv_powseries


MOO				        *moo.vim* *moo-syntax* *moo-синтаксис*

Если вы используете в выражениях комментарии в стиле C и сталкиваетесь 
с нарушениями подсветки, то можете использовать расширенные соответствия для
комментариев в стиле C (ценой снижения производительности):
>
	:let moo_extended_cstyle_comments = 1

Для отключения подсветки шаблонов замены местоимений внутри строк:
>
	:let moo_no_pronoun_sub = 1

Для отключения подсветки оператора регулярных выражений '%|' и парных '%(' и
'%)' внутри строк:
>
	:let moo_no_regexp = 1

Несбалансированные двойные кавычки могут распознаваться и подсвечиваться как
ошибки:
>
	:let moo_unmatched_quotes = 1

Для подсветки встроенных свойств (.name, .location, .programmer и т.д.):
>
	:let moo_builtin_properties = 1

Неизвестные встроенные функции могут распознаваться и подсвечиваться как
ошибки. При использовании этой особенности вы можете добавлять собственные
расширения в группу mooKnownBuiltinFunction. Для включения данной особенности
используйте команду
>
	:let moo_unknown_builtin_functions = 1

Приведём пример добавления функции sprintf() к списку известных встроенных
функций:
>
	:syn keyword mooKnownBuiltinFunction sprintf contained


MSQL			             *msql.vim* *msql-syntax* *msql-синтаксис*

В сценарии подсветки синтаксиса msql используются две настройки.

Если вы желаете использовать подсветку синтаксиса SQL в строках, используйте
команду
>
	:let msql_sql_query = 1

Синхронизация подсветки синтаксиса выполняется за 100 строк до первой видимой
на экране строки. Если вы предпочитаете использовать другое значение, то
можете задать его с помощью переменной "msql_minlines". Например:
>
	:let msql_minlines = 200


NCF				        *ncf.vim* *ncf-syntax* *ncf-синтаксис*

Сценарий подсветки синтаксиса NCF предоставляет единственную настройку.

Если вы хотите подсвечивать нераспознанные сценарием ncf.vim предложения как
ошибки, то используйте команду
>
	:let ncf_highlight_unknowns = 1

В противном случае не задавайте значение этой переменной.


NROFF			          *nroff.vim* *nroff-syntax* *nroff-синтаксис*

Правила подсветки синтаксиса для nroff работают с AT&T n/troff без
дополнительных настроек. Для включения дополнительных особенностей GNU groff
вам может потребоваться назначить несколько переменных.

Например, в поставке Linux и BSD в качестве пакета для обработки текста по
умолчанию используется groff. Чтобы включить дополнительные особенности
подсветки синтаксиса для groff добавьте в сценарий запуска следующую строку:
>
  :let b:nroff_is_groff = 1

Groff отличается от старого AT&T n/troff, который всё ещё можно встретить 
в Solaris. Макросы groff и имена запросов могут быть длиннее, чем 2 символа,
кроме того в нём имеются расширения языковых примитивов. Например, 
в AT&T troff доступ к двузначному числу номера года осуществляется с помощью
запроса \(yr. В groff можно использовать тот же самый запрос, который
распознаётся ради сохранения совместимости, либо можно использовать запрос 
с применением синтаксиса groff: \[yr]. Более того, вы можете напрямую
использовать 4-значное число номера года при помощи \[year]. Запросы макросов
могут быть длиннее, чем 2 символа, например GNU mm позволяет использовать
запросы ".VERBON" и ".VERBOFF" для создания блоков текста, который должен быть
передан как есть.

Чтобы добиться наилучшего вывода с использованием g/troff рекомендуется
следовать простым правилам пунктуации и расстановки пробелов:

1. Не оставлять пустые пробелы в конце строк.

2. Оставлять один и только один пробел после точки, восклицательного знака 
   и т.п., завершающих предложение.

3. По причинам, отмеченным выше, лучше всего использовать перенос строки после
   всех завершающих предложение символов пунктуации.

Причина, кроющаяся за этими необычными рекомендациями, заключается в том, что
в g/n/troff встроен такой алгоритм переноса строк, что он может быть легко
нарушен, если не следовать вышеперечисленным правилам.

В отличие от TeX, troff заполняет текст построчно, а не по абзацам, кроме того
в нём нет идеи стягивания или вытягивания, поэтому все горизонтальные и
вертикальные пробелы выводятся как есть.

Это означает, что вам следует быть внимательным, чтобы не использовать между
предложениями больше пробелов, чем вы хотели бы видеть в окончательном
документе. По этой причине общепринятой практикой является вставка переносов
строк непосредственно после символов пунктуации. Если вы хотите, чтобы текст в
окончательном документе после обработки выглядел "ровным", то в исходном
тексте необходимо поддерживать постоянное количество пробелов. Чтобы помечать
в тексте два и более пробелов после символов пунктуации, а также лишние
пробелы на хвосте строк, как ошибку, используйте 
>
  :let nroff_space_errors = 1

В вашем распоряжении имеется ещё один приём обнаружения лишних пробелов и
других ошибок, влияющих на правильное форматирование документа после
обработки. Для этого вам потребуется определить бросающиеся в глаза группы
подсветки "nroffDefinition" и "nroffDefSpecial" в файле настроек. Например,
>
  hi def nroffDefinition term=italic cterm=italic gui=reverse
  hi def nroffDefSpecial term=italic,bold cterm=italic,bold
			 \ gui=reverse,bold

Если вы хотите легко перемещаться между записями препроцессора в исходном
документе, как в случае с отметками разделов, то можете добавить в .vimrc
следующую команду:
>
	let b:preprocs_as_sections = 1

Кроме того, файл синтаксиса добавляет в пакете ms дополнительную отметку
расширенного абзаца (.XP).

Наконец, в поставку входит сценарий подсветки синтаксиса |groff.vim|, который
можно применять для включения подсветки синтаксиса groff как в для всех файлов
по умолчанию, так и для отдельных файлов.


OCAML			          *ocaml.vim* *ocaml-syntax* *ocaml-синтаксис*

Файл подсветки синтаксиса OCaml применяется к файлам с расширениями .ml, .mli,
.mll и .mly. Назначив переменную
>
	:let ocaml_revised = 1

вы можете переключиться от стандартного синтаксиса OCaml к переработанному
синтаксису, который поддерживается препроцессором camlp4. 

Переменная
>
	:let ocaml_noend_error = 1

позволяет предотвратить подсветку "end" как ошибку, что полезно в том случае,
если исходный текст содержит очень длинные структуры, которые Vim не может
правильно синхронизировать.


PAPP				     *papp.vim* *papp-syntax* *papp-синтаксис*

Сценарий подсветки синтаксиса PApp применяется к файлам .papp и, в несколько
меньшей степени, к файлам .pxml и .pxml, которые используют формат xml и
представляют собой смесь синтаксических правил для perl/xml/html/чего-то ещё.
По умолчанию всё, что находится в разделах phtml или pxml считается строкой со
встроенными командами для препроцессора. Если вы назначите переменную
>
	:let papp_include_html=1

в сценарии запуска, то будет предприниматься попытка подсветки кода html
внутри разделов phtml, однако это происходит довольно медленно и результат
такой подсветки слишком цветной, чтобы можно было нормально работать ;)

Последнюю версию сценария подсветки синтаксиса papp.vim можно получить по
адресу http://papp.plan9.de.


PASCAL			       *pascal.vim* *pascal-syntax* *pascal-синтаксис*

Файлы с расширениями "*.p" могут быть как файлами Progress, так и файлами
Pascal. Если автоматическое определение не срабатывает в вашем случае, или вы
не занимаетесь редактированием файлов Progress, то можете добавить к сценарию
запуска .vimrc следующую команду:
>
   :let filetype_p = "pascal"

Сценарий подсветки синтаксиса для Pascal был существенно доработан с учётом
некоторых расширений, предоставляемых в Turbo Pascal, Free Pascal Compiler и
GNU Pascal Compiler. Кроме того, поддерживаются ключевые слова Delphi. По
умолчанию включены особенности Turbo Pascal 7.0. Если вы предпочитаете
использовать только стандартные ключевые слова Pascal, то добавьте следующую
строку к сценарию запуска:
>
   :let pascal_traditional=1

Чтобы включить особенности, применяемые в Delphi (вроде однострочных
комментариев, ключевых слов и т.д.), используйте команду:
>
   :let pascal_delphi=1

Переменная pascal_symbol_operator управляет применением цвета Operator к
символам операторов, таким как +, * и т.д. Чтобы подсвечивать символы
операторов добавьте к сценарию запуска команду
>
   :let pascal_symbol_operator=1

По умолчанию также подсвечиваются некоторые функции. Для отключения такой
подсветки используйте команду
>
   :let pascal_no_functions=1

Кроме того, имеется ряд переменных, относящихся к использованию определённых
компиляторов. Помимо pascal_delphi имеются также переменные pascal_gpc и
pascal_fpc. Используемые по умолчанию расширения пытаются соответствовать
Turbo Pascal.
>
   :let pascal_gpc=1

или
>
   :let pascal_fpc=1

Чтобы обеспечить определение строк в единственной строке кода, вы можете
определить переменную pascal_one_line_string.
>
   :let pascal_one_line_string=1

Если вам не нравятся символы <Tab>, то вы можете включить переменную
pascal_no_tabs:
>
   :let pascal_no_tabs=1

В этом случае символы табуляции будут подсвечиваться как ошибки.


PERL			             *perl.vim* *perl-syntax* *perl-синтаксис*

Сценарий подсветки синтаксиса для perl позволяет применять ряд дополнительных
настроек.

Если вы используете файлы POD или фрагменты POD, то вам может пригодиться
следующая команда:
>
	:let perl_include_pod = 1

Для обработки ссылок на пакеты в именах переменных и функций отличным от
остальной части имени способом (например, 'PkgName::' в '$PkgName::VarName'),
используйте команду
>
	:let perl_want_scope_in_variables = 1

Для разбора сложных конструкций, вроде '@{${"цололо"}}' используйте команду
>
	:let perl_extended_vars = 1

Вы можете изменить подсветку строк. По умолчанию, строки и конструкции qq
подсвечиваются как первая строка. Если вы включите переменную
perl_string_as_statement, то они будут подсвечиваться как вторая строка.

   "hello world!"; qq|hello world|;
   ^^^^^^^^^^^^^^NN^^^^^^^^^^^^^^^N	  (perl_string_as_statement не
                                           определена)
   S^^^^^^^^^^^^SNNSSS^^^^^^^^^^^SN	  (perl_string_as_statement
                                           определена)

(^ = группа perlString, S = группа perlStatement, N = без подсветки)

Синхронизация использует три настройки, две из них используются для отключения
вызова синхронизации в некоторых случаях и должны использоваться только в том
случае, если настройки по умолчанию работают неправильно. Если во время
прокрутки текст на всём экране внезапно изменяет цвет, то вы можете попытаться
отключить одну из этих переменных. Если вы сможете определить, какая именно
строка вызывает ошибку подсветки, то сообщите мне об этом. Одна из этих
переменных управляет синхронизацией на выражениях "^\s*sub\s*", а другая на
выражениях вида "^[$@%]".
>
	:let perl_no_sync_on_sub
	:let perl_no_sync_on_global_var

Вы можете также установить максимальное количество строк, которые Vim должен
просматривать до первой строки на экране в поиске конструкций для подсветки
синтаксиса. С этой целью применяется переменная
>
	:let perl_sync_dist = 100

Если вы хотите использовать складки в соответствии с синтаксисом perl, то
назначьте переменную perl_fold:
>
       :let perl_fold = 1

<
     		               *php.vim* *php3.vim* *php-syntax* *php3-syntax*
PHP3 и PHP4		                      *php-синтаксис* *php3-синтаксис*

[замечание: раннее этот сценарий назывался "php3", но поскольку теперь в нём
также поддерживается php4, то он был переименован в "php"]

Ниже приводятся различные настройки для сценария подсветки синтаксиса php.

Чтобы включить подсветку синтаксиса SQL внутри группы String:
>
  let php_sql_query = 1

для подсветки методов Baselib:
>
  let php_baselib = 1

для включения подсветки синтаксиса HTML внутри строк:
>
  let php_htmlInStrings = 1

для использования старого стиля подсветки:
>
  let php_oldStyle = 1

для включения подсветки коротких тэгов в стиле ASP:
>
  let php_asp_tags = 1

для отключения коротких тэгов:
>
  let php_noShortTags = 1

для подсветки ошибок в закрывающих скобках ] или ):
>
  let php_parent_error_close = 1

для пропуска закрывающего тэга php при наличии открывающей скобки ( или [ и
отсутствии парной закрывающей скобки:
>
  let php_parent_error_open = 1

для включения складок для классов и функций:
>
  let php_folding = 1

для выбора метода синхронизации:
>

  let php_sync_method = x

где:

x = -1 для синхронизации методом поиска (по умолчанию),
x > 0  для синхронизации по меньшей мере x предыдущих строк,
x = 0  для синхронизации от начала.


PPWIZARD		          *ppwiz.vim* *ppwiz-syntax* *ppwiz-синтаксис*

PPWizard это препроцессор для файлов HTML и OS/2 INF.

Данный сценарий синтаксиса позволяет использовать следующие настройки:

- Переменная ppwiz_highlight_defs задаёт режим подсветки для определений
  PPWizard. Допустимы следующие значения этой переменной:

  ppwiz_highlight_defs = 1 
    предложения #define PPWizard сохраняют подсветку синтаксиса содержимого
    (например, макросов и переменных PPWizard)

  ppwiz_highlight_defs = 2 
    предложения #define и #evaluate отображаются одним цветом, за исключения
    символов продолжения строки

  По умолчанию для используется значение ppwiz_highlight_defs = 1.

- ppwiz_with_html 
    если значение этой переменной равно 1 (по умолчанию), то код HTML
    подсвечивается; если значение переменной ppwiz_with_html равно 0, то код
    HTML рассматривается как обычный текст.


PHTML			          *phtml.vim* *phtml-syntax* *phtml-синтаксис*

Сценарий подсветки синтаксиса phtml использует две настройки.

Для включения подсветки синтаксиса SQL внутри группы String используйте
команду:
>
	:let phtml_sql_query = 1

По умолчанию синхронизация выполняется за 100 строк до первой видимой на
экране строки. Вы можете изменить это значение с помощью переменной
"phtml_minlines":
>
	:let phtml_minlines = 200


POSTSCRIPT	            *postscr.vim* *postscr-syntax* *postscr-синтаксис*

Сценарий подсветки синтаксиса для языка PostScript позволяет использовать
несколько дополнительных настроек.

Во-первых, вы можете настраивать подсветку синтаксиса в соответствии с
правилами необходимой версии языка PostScript. В настоящий момент известно три
таких версии, или, как их ещё называют, уровня. Уровень 1 это первоначальная
базовая версия, включающая все расширения языка до момента выпуска уровня 2.
Уровень 2, в свою очередь, является наиболее распространённой версией, в него
включены все расширения вплоть до выпуска уровня 3. Уровень 3 является самой
последней версией из поддерживаемых в настоящий момент. Вы можете выбрать
необходимую версию для подсветки синтаксиса при помощи переменной
postscr_level, которая определяется по команде
>
	:let postscr_level=2

Если данная переменная не определена, то её значением по умолчанию является 2,
что соответствует уровню 2, поскольку на сегодняшний день это самая
распространённая версия языка PostScript.

Обратите внимание, что не все интерпретаторы языка PostScript поддерживают
полный набор особенностей определённого уровня этого языка. В частности,
%!PS-Adobe-3.0 в начале файла PostScript НЕ означает, что данный файл
представляет собой PostScript уровня 3!

Если вы работаете с Display PostScript, то можете включить специальную
поддержку особенностей Display PS путём определения переменной postscr_display
по команде
>
	:let postscr_display=1

Если вы работаете с Ghostscript, то можете включить подсветку специфических
для Ghostscript особенностей путём определения переменной postscr_ghostscript:
>
	:let postscr_ghostscript=1

PostScript -- это очень большой язык, в нём присутствует множество
предопределённых элементов. Хотя подсветка каждого такого элемента может быть
полезна, на медленных компьютерах это будет сильно тормозить работу Vim,
поэтому имена шрифтов и кодировок символов по умолчанию не подсвечиваются. 
Это не должно вызывать неудобств, если вы, конечно, не работаете
непосредственно с данными особенностями. Для их подсветки можете
воспользоваться двумя соответствующими переменными:
>
	:let postscr_fonts=1
	:let postscr_encodings=1

Кроме того, имеется стилистическая настройка, касающаяся подсветки and, or 
и not. В языке PostScript действие указанных операторов зависит от типа
операндов, к которым они применяются. Если операнды являются булевыми
величинами, то указанные операторы будут логическими операторами, а если их
применяют к числам, то они являются бинарными операторами. Поскольку бинарные
и логические операторы могут подсвечиваться по разному, то их подсветка может
быть выполнена двумя способами. По умолчанию указанные операторы считаются
логическими, но их можно подсвечивать как бинарные операторы, если определить
переменную postscr_andornot_binary:
>
	:let postscr_andornot_binary=1
<

		                                    *ptcap.vim* *ptcap-syntax*
		                            *termcap-syntax* *printcap-syntax*
PRINTCAP + TERMCAP  *ptcap-синтаксис* *termcap-синтаксис* *printcap-синтаксис*

Этот сценарий подсветки синтаксиса применяется для работы с базами данных
printcap и termcap.

Чтобы Vim мог распознавать файлы printcap/termcap, имена которых не
соответствуют шаблонам *printcap*, *termcap*, вам необходимо поместить в файл
|myfiletypefile| дополнительные шаблоны в соответствии с вашими требованиями.
Для работы с этими шаблонами вам необходимо присвоить переменной
"b:ptcap_type" значение "print" или "term", а опции 'filetype' присвоить
значение "ptcap".

Например, чтобы Vim распознавал все файлы в каталоге /etc/termcaps/ как файлы
termcap, добавьте следующую команду:
>
   :au BufNewFile,BufRead /etc/termcaps/* let b:ptcap_type = "term" |
				       \ set filetype=ptcap

Если вы столкнётесь с ошибками подсветки при прокрутке назад, которые исчезают
при обновлении экрана по команде CTRL-L, попытайтесь увеличить значение
переменной "ptcap_minlines":
>
   :let ptcap_minlines = 50

(По умолчанию используется значение 20 строк.)


PROGRESS	         *progress.vim* *progress-syntax* *progress-синтаксис*

Файлы с расширением "*.w" могут быть как файлами Progress, так и файлами cweb.
Если автоматическое определение не работает в вашей системе или вы не
занимаетесь редактированием файлов cweb, то можете добавить в сценарий запуска
vimrc следующую команду:
>
   :let filetype_w = "progress"

То же самое касается и файлов "*.i", которые могут быть файлами ассемблера, и
файлов "*.p", которые могут быть файлами Pascal. Если вы не занимаетесь
редактированием файлов ассемблера и Pascal, то можете воспользоваться
следующими командами:
>
   :let filetype_i = "progress"
   :let filetype_p = "progress"


PYTHON 			       *python.vim* *python-syntax* *python-синтаксис*

Для настройки подсветки синтаксиса в файлах Python используются следующие
переменные:

Для подсветки чисел:
>
	:let python_highlight_numbers = 1

Для подсветки встроенных функций:
>
	:let python_highlight_builtins = 1

Для подсветки стандартных исключений:
>
	:let python_highlight_exceptions = 1

Для подсветки пробелов в конце строк и смешанных символов табуляции и
пробелов:
>
	:let python_highlight_space_errors = 1

Если вы хотите использовать все возможные группы подсветки в Python, то можете
использовать команду
>
	:let python_highlight_all = 1

которая заменяет собой все предыдущие.

QUAKE			          *quake.vim* *quake-syntax* *quake-синтаксис*

Сценарий подсветки синтаксиса для Quake позволяет работать с файлами почти
всех стрелялок "от первого лица", построенных на движке Quake. Однако,
названия команд могут незначительно отличаться между разными играми (Quake,
Quake 2 и Quake 3 Arena), поэтому сценарий проверяет наличие трёх глобальных
переменных с тем, чтобы пользователи могли указать какие команды допустимы 
в файлах, с которыми они работают. Эти переменные работают следующим образом:

для подсветки команд, доступных только в Quake:
>
	:let quake_is_quake1 = 1

для подсветки команд, доступных только в Quake 2:
>
	:let quake_is_quake2 = 1

для подсветки команд, доступных только в Quake 3 Arena:
>
	:let quake_is_quake3 = 1

Допустимы любые комбинации указанных переменных, однако при этом возможно
включение подсветки большего количества команд, чем набор, предоставляемый
данной игрой.


READLINE		 *readline.vim* *readline-syntax* *readline-синтаксис*

Библиотека readline в основном используется совместно с оболочкой BASH,
которая добавляет несколько собственных команд и опций к уже доступным. 
Для того, чтобы подсвечивать также эти дополнительные элементы вы можете
добавить в сценарий |vimrc| или просто набрать в командной строке перед
загрузкой файла с синтаксисом readline следующую команду:
>
	let readline_has_bash = 1

Это позволяет добавить подсветку для команд, которые используются в BASH
(версии 2.05a и более поздних, а также частично более ранних версий).


REXX			             *rexx.vim* *rexx-syntax* *rexx-синтаксис*

Если вы сталкиваетесь с ошибками подсветки синтаксиса при прокрутке назад,
которые исправляются при обновлении экрана по команде CTRL-L, то можете
увеличить значение переменной "rexx_minlines":
>
	:let rexx_minlines = 50

В данном случае синхронизация подсветки синтаксиса будет начинаться 
за 50 строк до первой отображаемой на экране строки. По умолчанию используется
значение 10. Использование больших значений может замедлять выполнение
обновления.


RUBY			             *ruby.vim* *ruby-syntax* *ruby-синтаксис*

В сценарии подсветки синтаксиса для Ruby используется несколько дополнительных
настроек.

По умолчанию, ключевое слово "end" подсвечивается в соответствии с открывающим
предложением блока, который оно закрывает. Такая возможность, несмотря на все
её достоинства, может дорого обходиться: при медленном обновлении экрана (или
на терминале с бедной поддержкой цвета) вы можете отключить её путём
определения переменной "ruby_no_expensive":
>
	:let ruby_no_expensive = 1

В этом случае для всех управляющих ключевых слов будет применяться один и тот
же цвет.

В том случае, если вы хотите использовать вышеописанную возможность, но
сталкиваетесь с ошибками подсветки при прокрутке назад, которые исправляются
при обновлении экрана по команде CTRL-L, попытайтесь увеличить значение
переменной "ruby_minlines":
>
	:let ruby_minlines = 100

По умолчанию, значение этой переменной равно 50. В идеальном случае её
значение должно быть достаточно большим, чтобы охватывать самый большой класс
или модуль в вашем коде.

Наконец, если вы не хотите, чтобы при подсветки использовалось слишком много
цветов, то определите переменную "ruby_no_identifiers":
>
	:let ruby_no_identifiers = 1

В этом случае не будет происходить подсветка таких специальных имён, как
"ConstantName", "$global_var", "@instance_var", "| iterator |" и ":symbol".


SDL				        *sdl.vim* *sdl-syntax* *sdl-синтаксис*

В сценарии подсветки синтаксиса SDL возможно не определено несколько ключевых
слов, но в SDL используется такое огромное их количество, что охватить все
практически невозможно.

В новом стандарте, SDL-2000, указывается, что все имена являются
регистрозависимыми (раннее это было не так) и что все ключевые слова должны
использовать символы либо только в нижнем регистре, либо только в верхнем
регистре. Чтобы научить сценарий подсветки отражать этот факт, определите
следующую переменную:
>
	:let sdl_2000=1

Вышеуказанная команда также определяет множество новых ключевых слов. Если вы
хотите исключить подсветку старых ключевых слов, что, наверное, правильно,
используйте команду
>
	:let SDL_no_96=1

Форматирование отступов также не является идеальным, но я вполне доволен его
поведением в моих собственных проектах.


SED				        *sed.vim* *sed-syntax* *sed-синтаксис*

Для включения отличия символов табуляции от обычных пробелов (достигается
путём использования группы подсветки Todo для символов табуляции) определите
переменную "highlight_sedtabs" при помощи команды
>
	:let highlight_sedtabs = 1

в файле vimrc (этот специальный режим подсветки применяется только к
символам табуляции внутри шаблонов поиска, текста для подстановки, адресов или
текста, включаемого с помощью команд добавления/изменения/вставки). Если вы
включите вышеуказанную возможность, то можете назначить ширину символа
табуляции равной 1 символу; в этом случае вы легко сможете сосчитать
количество символов табуляции в строке.

Глюки:

  Команда преобразования (y) рассматривается сценарием подсветки синтаксиса
  точно так же, как команда подстановки. Это означает, что с точки зрения
  сценария подсветки синтаксиса, команда преобразования принимает те же самые
  флаги, что и команда подстановки, хотя в действительности это не так:
  команда преобразования не допускает использования флагов. Я терплю этот
  глюк, поскольку данные команды требуют очень сложной обработки (95 шаблонов,
  по одному на каждый допустимый разделитель шаблонов).


SGML				     *sgml.vim* *sgml-syntax* *sgml-синтаксис*

Схема подсветки синтаксиса для тэгов в файлах SGML работает следующим образом.

Символы <> в открывающих тэгах подсвечиваются отличным образом от символов </>
закрывающего тэга. Это сделано специально! Открывающие тэги используют группу
'Function', в то время как закрывающие тэги используют группу 'Type' (вы
можете уточнить, как определены эти группы на вашей машине в сценарии
syntax.vim).

Известные имена тэгов подсвечиваются точно так же, как предложения в C.
Неизвестные имена тэгов не подсвечиваются, что позволяет легко находить
ошибки.

Обратите внимание, что то же самое касается и имён параметров (атрибутов).
Известные атрибуты подсвечиваются отличным от неизвестных образом.

Некоторые тэги SGML используются для изменения стиля отображения текста.
Сценарий подсветки синтаксиса sgml.vim распознаёт тэги <varname> <emphasis>
<command> <function> <literal> <replaceable> <ulink> и <link> и изменяет
текст, заключённый в них, соответствующим образом.

Если вы желаете изменить стиль текста в этих тэгах, то вы должны
переопределить следующие синтаксические группы:

    - sgmlBold
    - sgmlBoldItalic
    - sgmlUnderline
    - sgmlItalic
    - sgmlLink for links

Вам необходимо переопределить все указанные группы, чтобы переопределение
заработало, а также определить в vimrc следующую переменную:
>
   let sgml_my_rendering=1

(это правило связано с порядком чтения файлов в процессе инициализации).

Вы можете также отключить особый вид текста внутри указанных тэгов путём
добавления в файл vimrc следующей строки:
>
   let sgml_no_rendering=1

(Этот раздел основан на тексте справки для сценария html.vim, который был
написан Клаудио Фляйнером [Claudio Fleiner <claudio@fleiner.com>])


SH				           *sh.vim* *sh-syntax* *sh-синтаксис*

Этот сценарий позволяет работать со сценариями "обычной" оболочки Unix
(Bourne) sh, bash и сценариями оболочки Korn.

Vim пытается определить тип используемой оболочки по имени файла:
>
    ksh : .kshrc* *.ksh
    bash: .bashrc* bashrc bash.bashrc .bash_profile* *.bash

Если ни один из перечисленных вариантов не подходит, то проверяется первая
строка в файле (например, /bin/sh, /bin/ksh или /bin/bash). Если в первой
строке файла указано имя одной из оболочек, то используется подсветка
синтаксиса для сценариев оболочки этого типа. В то же время, некоторые файлы
(например, .profile) могут быть сценариями оболочки, но тип оболочки в них не
указывается. Более того, на некоторых системах создаётся символическая связь
между sh и "bash" (linux) или "ksh" (posix).

Вы можете определить один из типов оболочки в качестве глобального значения по
умолчанию, поместив в файл .vimrc одну из нижеперечисленных команд:

    ksh: >
	let is_kornshell = 1
<   bash: >
	let is_bash	 = 1
<   sh: >
	let is_sh	 = 1

Если вы поместите в файле .vimrc команду
>
	let g:sh_fold_enabled= 1
>
то вы сможете применять синтаксические складки к различным синтаксическим
элементам (например, к HereDoc и телам функций). Подробнее см. |:syn-складки|.

Если вы сталкиваетесь с ошибками подсветки при прокрутке назад, которые
исчезают при обновлении экрана по команде CTRL-L, попытайтесь увеличить
значение внутренней переменной "sh_minlines":
>
	let sh_minlines = 500

В данном случае синхронизация синтаксиса будет начинаться за 500 строк до
первой видимой на экране строки. По умолчанию используется значение 200.
К сожалению, использование больших значений этой переменной может замедлять
обновление экрана.

Если в тексте вашего сценария оболочки содержится не так много элементов, по
которым можно выполнять синхронизацию подсветки синтаксиса, то обновление
экрана может выполняться очень медленно. Чтобы ускорить работу вы можете
изменить значение переменной "sh_maxlines". Например:
>
	let sh_maxlines = 100
<
По умолчанию используется значение в два раза большее, чем значение переменной
sh_minlines. Для ускорения обработки используйте меньшее значение. При этом вы
можете столкнуться с ошибками подсветки синтаксиса.


				                                    *spup.vim* 
						                 *spup-syntax*
SPEEDUP (Симулятор промышленного производства от AspenTech)   *spup-синтаксис*

Сценарий подсветки синтаксиса для Speedup допускает использование следующих
дополнительных настроек:

- strict_subsections : если определить эту переменную, то в качестве
  предложений будут подсвечиваться только ключевые слова для разделов и
  подразделов, но не остальные ключевые слова (вроде WITHIN в разделе
  OPERATION).

- highlight_types : если определить эту переменную, то потоковые типы, вроде
  температуры или давления, будут подсвечиваться как Type, а не как обычное
  имя (Identifier). Сюда включаются типы, которые обычно можно найти в разделе
  DECLARE; если вы определяете собственные типы, то их следует включить в
  сценарий подсветки синтаксиса.
  
- oneline_comments : данная переменная может принимать значения от 1 до 3 и
  определяет подсветку комментариев в стиле #.

  oneline_comments = 1 : допускает присутствие обычного кода Speedup после
		         чётного количества #.

  oneline_comments = 2 : подсвечивает код, начиная со второго символа #, как
			 ошибку. Это значение используется по умолчанию.

  oneline_comments = 3 : подсвечивает как ошибку в синтаксисе всю строку, если
			 в неё содержится более одного символа #.

Поскольку некоторые разделы, особенно OPERATION, могут быть довольно большими
из-за команд PRESET, настройка синхронизации может иметь критическое значение.
Если вы использует достаточно быстрый компьютер, то можете увеличить значения
minlines и/или maxlines в конце сценария подсветки синтаксиса.


TCSH			             *tcsh.vim* *tcsh-syntax* *tcsh-синтаксис*

Здесь рассматривается работа сценария подсветки синтаксиса для файлов оболочки
"tcsh". Эта оболочка является надмножеством оболочки csh. Об определении типа
файла см. в разделе |csh.vim|.

Оболочка tcsh не позволяет использовать в строках последовательность \", если
не определена переменная оболочки "backslash_quote". Если вы желаете, чтобы
Vim считал, что конструкции с использованием обратной косой черты невозможны,
то добавьте к файлу .vimrc следующую строку:
>
	:let tcsh_backslash_quote = 0

Если вы заметите ошибки в подсветке синтаксиса при прокрутке назад, которые
исправляются при обновлении экрана по команде CTRL-L, то попытайтесь увеличить
значение переменной "tcsh_minlines":
>
	:let tcsh_minlines = 100

В данном случае синхронизация подсветки синтаксиса будет начинаться за 100
строк до первой видимой на экране строки. По умолчанию эта переменная имеет
значение 15. Использование больших значений этой переменной может привести к
замедлению обновления экрана.


TEX			                *tex.vim* *tex-syntax* *tex-синтаксис*

Дополнительные группы Comment/Math? ~

Сценарий подсветки синтаксиса tex поддерживает TeX, LaTeX и в некоторой
степени AmsTeX. Сценарий определяет три основных зоны подсветки: обычную зону
(normal), зону TeX (texZone) и зону математики (texMathZone). Хотя сценарий
написан так, чтобы границы зон определялись по возможности максимально
корректно, синхронизация зон, отделённых символами $...$ и $$...$$ не может
быть выполнена, поскольку шаблоны начала и конца не отличаются друг от друга.
Поэтому, создан специальный комментарий TeX 
>
	%stopzone

который принудительно завершает применение подсветки texZone или texMathZone.

Медленная работа подсветки синтаксиса? ~

Если вы работаете на медленном компьютере, то ускорить обработку можно путём
уменьшения следующих значений:
>
	:syn sync maxlines=200
	:syn sync minlines=50

(особенно полезно уменьшение второго значения). На быстрых компьютерах можно
наоборот увеличить указанные значения. Указанные значения влияют на
синхронизацию (т.е. определение синтаксической группы, к которой принадлежит
фрагмент текста в самой верхней строке экрана).

Избыточная подсветка ошибок? ~

Сценарий <tex.vim> поддерживает проверку различных лексических ошибок, однако,
несмотря на то, что проверка ошибок бывает полезна, иногда подсвечиваются
ошибки в тех местах, где на самом деле их нет. Если такое поведение вас не
устраивает, то вы можете добавить в сценарий <.vimrc> следующую команду:
>
	let tex_no_error=1

что приведёт к подавлению проверки ошибок в <tex.vim>.

Новая группа Math? ~

Если вы желаете добавить новую математическую группу в LaTeX, изучите
нижеприведённый пример, который иллюстрирует необходимые изменения в сценарии
подсветки синтаксиса:
>
    syn cluster texMathZones add=texMathZoneLOCAL
    syn region texMathZoneLOCAL start="\\begin\s*{\s*LOCALMATH\s*}"
       \ end="\\end\s*{\s*LOCALMATH\s*}" keepend
       \ contains=@texMathZoneGroup
    if !exists("tex_no_math")
     syn sync match texSyncMathZoneLOCAL grouphere texMathZoneLOCAL
       \ "\\begin\s*{\s*LOCALMATH\*\s*}"
     syn sync match texSyncMathZoneLOCAL groupthere NONE
       \ "\\end\s*{\s*LOCALMATH\*\s*}"
    endif
    hi link texMathZoneLOCAL texMath
<
LOCALMATH следует заменить на имя вашей новой математической группы, после
чего этот код нужно поместить в файл .vim/after/syntax/tex.vim.

Начало нового стиля? ~

Вы можете использовать команду "\makeatletter" в файлах *.tex, которая
позволяет использовать символ "@" в командах. В то же время, поскольку файл
*.tex не имеет одного из расширений sty, cls, clo, dtx, ltx, то подсветка
синтаксиса будет отмечать такое использование символа @ как ошибку. Для
решения этой проблемы используйте команды
>
	:let b:tex_stylish = 1
	:set ft=tex

Если поместить "let g:tex_stylish=1" в файл <.vimrc>, то сценарий
<syntax/tex.vim> будет всегда допускать подобное использование @.


TF				           *tf.vim* *tf-syntax* *tf-синтаксис*

Сценарий подсветки синтаксиса tf использует единственную дополнительную
настройку.

При выполнении синхронизации значение minlines по умолчанию принимается 
равным 100. Если вы предпочитаете иное значение, то можете изменить переменную
"tf_minlines" соответствующим образом. Например:
>
	:let tf_minlines = ваше значение


VIM			                *vim.vim* *vim-syntax* *vim-синтаксис*

При подсветке синтаксиса сценариев для Vim имеется возможность выбора между
более точной и более быстрой работой. Для повышения точности подсветки вы
можете увеличить значение переменной g:vim_minlines. Переменная g:vim_maxlines
может применяться для ускорения обновления экрана (подробнее см. в разделе
|:syn-синхронизация|).

	g:vim_minlines : используется для настройки минимального количества
			 строк для синхронизации
	g:vim_maxlines : используется для настройки максимального количества
	                 строк для синхронизации

Переменная g:vimembedscript позволяет выполнять более быструю загрузку
сценария подсветки синтаксиса для файлов Vim за счёт отключения поддержки
подсветки синтаксиса внешних сценарных языков (в настоящий момент это perl,
python, ruby и tcl).

	g:vimembedscript == 1 (по умолчанию)	<vim.vim> использует
						подсветку встроенных сценарных
						языков: perl, python, ruby и
						tcl.

	g:vimembedscript == 0			Подсветка встроенных сценарных
						языков не загружается.


XF86CONFIG		 *xf86conf.vim* *xf86conf-syntax* *xf86conf-синтаксис*

Синтаксис файла XF86Config отличается в XFree86 v3.x и v4.x. Сценарий
подсветки синтаксиса поддерживает оба варианта. Хотя для выбора необходимого
варианта синтаксиса используется автоматическое определение, его алгоритм
нельзя признать идеальным. В силу этого вам может потребоваться указать версию
вручную. Для этой цели применяется переменная xf86conf_xfree86_version,
которая может принимать значения 3 и 4 в зависимости от версии XFree86.
Значение этой переменной задаётся в файле .vimrc. Например:
>
	:let xf86conf_xfree86_version=3

При редактировании файлов разных версий применяйте переменную
b:xf86conf_xfree86_version.

Обратите внимание, что пробелы и подчёркивания в именах опций не
поддерживаются. Используйте "SyncOnGreen" вместо "__s yn con gr_e_e_n", если
вы хотите, чтобы имена опций подсвечивались.


XML			                *xml.vim* *xml-syntax* *xml-синтаксис*

Пространства имён XML по умолчанию подсвечиваются. Вы можете отказаться от
этой возможности при помощи специальной глобальной переменной:
>
	:let g:xml_namespace_transparent=1
<
					           *xml-folding* *xml-складки*
Файл синтаксиса xml позволяет также использовать синтаксические |складки| 
(см. |:syn-складки|), которые определяются в соответствии с начальными и
конечными тэгами. Эта возможность включается с помощью команд
>
	:let g:xml_syntax_folding = 1
	:set foldmethod=syntax

Замечание: использование синтаксических складок может существенно замедлить
подсветку синтаксиса, особенно в больших файлах.


X Pixmaps (XPM)		                *xpm.vim* *xpm-syntax* *xpm-синтаксис*

Сценарий подсветки синтаксиса xpm.vim динамически создаёт синтаксические
элементы в соответствии с содержимым файла XPM. В силу этого обстоятельства
при внесении изменений, например в строки определения цветов, вам потребуется
заново считать сценарий, например по команде ":set syn=xpm".

Чтобы скопировать "пиксел" с одним из цветов, применяйте команду "yl", после
чего используйте команду "P" для вставки его в какое-либо другое место.

Хотите рисовать с помощью мыши? Попробуйте выполнить следующий сценарий:
>
   :function! GetPixel()
   :   let c = getline(line("."))[col(".") - 1]
   :   echo c
   :   exe "noremap <LeftMouse> <LeftMouse>r".c
   :   exe "noremap <LeftDrag>	<LeftMouse>r".c
   :endfunction
   :noremap <RightMouse> <LeftMouse>:call GetPixel()<CR>
   :set guicursor=n:hor20	   " для просмотра цвета в позиции курсора
   
Этот код превращает правую кнопку мыши в пипетку, а левую кнопку мыши в
карандаш. Обратите внимание, что он будет работать с файлами XPM, которые
имеют только один символ на каждый пиксел. Кроме того, вы не должны нажимать
кнопку мыши за пределами строк с пикселами. Впрочем, вы можете сами
усовершенствовать этот сценарий.

Лучше всего использовать шрифт с квадратным размером ячеек, например
используйте такую настройку для X:
>
	:set guifont=-*-clean-medium-r-*-*-8-*-*-*-*-80-*

==============================================================================
5. Определение синтаксических правил   *:syn-define* *:syn-определение* *E410*

Vim распознаёт три типа синтаксических элементов:

1. Ключевое слово.
   Этот тип может включать только символы, допустимые в ключевых словам, в
   соответствии со значением опции 'iskeyword'. Он не может содержать другие
   синтаксические элементы. Соответствие проверяется по всему ключевому слову
   (символы ключевого слова отсутствуют перед соответствием и после него).
   Например, ключевое слово "if" будет найдено в "if(a=b)", но не в "ifdef x",
   поскольку "(" не является символом ключевого слова, а символ "d" --
   является.

2. Соответствие.
   Этот тип определяет соответствие единственному шаблону, заданному в форме
   регулярного выражения.

3. Область.
   Данный элемент начинается с соответствия шаблону регулярного выражения
   "start" и заканчивается соответствием шаблону регулярного выражения "end".
   Между указанными шаблонами может использоваться любой текст. Для пропуска
   соответствия шаблону "end" может применяться шаблон регулярного выражения
   "skip".

Несколько синтаксических элементов могут быть объединены в одну синтаксическую
группу. Синтаксической группе могут быть назначены параметры подсветки.
Например, вы можете определить элементы, задающие комментарий в стиле 
"/* ... */" и комментарий в стиле "// ...", после чего поместить оба элемента
в группу "Comment". Далее вы можете указать, что группа "Comment" отображается
жирным шрифтом и подсвечивается синим цветом. Вы можете создать по
синтаксической группе для каждого элемента или поместить все элементы в одну
группу, в зависимости от того, как именно вы желаете определить параметры
подсветки. Если вы используете отдельные группы для каждого отдельного
элемента, то вам придётся указывать параметры подсветки для большого числа
групп.

Обратите внимание, что синтаксические группы и группы подсветки похожи. Группа
подсветки позволяет определить параметры подсветки, которые применяются в
синтаксической группе с тем же именем.

Если одной и той же позиции соответствует несколько элементов, то используется
тот элемент, который был определён ПОСЛЕДНИМ. Таким образом, вы можете
переопределять раннее определённые синтаксические элементы путём использования
элемента, который соответствует тому же самому тексту. Однако, при этом
следует иметь ввиду, что ключевые слова всегда предшествуют соответствиям и
областям, а ключевое слово с регистрозависимым соответствием предшествуют
регистронезависимым ключевым словам.


ПРИОРИТЕТ			              *:syn-priority* *:syn-приоритет*

При наличии нескольких соответствий синтаксических элементов тексту
применяются следующие правила:

1. Если несколько элементов типа Соответствие или Область начинаются в одной и
   той же позиции, то применяется тот элемент, который был определён
   последним.
2. Ключевые слова имеют приоритет над Соответствиями и Областями.
3. Элемент, который начинается в более ранней позиции, имеет приоритет над
   элементами, которые начинаются в более поздних по тексту позициях.


РЕГИСТР СИМВОЛОВ                    *:syn-case* *:syn-регистр_символов* *E390*

:sy[ntax] case [match|ignore]
        Эта команда определяет механизм работы с регистром символов в
	последующих командах ":syntax". При использовании "match" регистр
	символов будет учитываться при определении соответствия, а при
	использовании "ignore" регистр символов учитываться не будет. Обратите
	внимание, что раннее определённые элементы не затрагиваются этой
	командой. Область её действия простирается до следующей команды
	":syntax case".

ОПРЕДЕЛЕНИЕ КЛЮЧЕВЫХ СЛОВ	          *:syn-keyword* *:syn-ключевые_слова*

:sy[ntax] keyword {имя_группы} [{параметры}] {ключевое_слово} .. [{параметры}]

	Данная команда позволяет определить список ключевых слов.

	{имя_группы}	    Имя синтаксической группы, например "Comment".
	[{параметры}]	    См. |:syn-параметры| ниже.
	{ключевое_слово} .. Список ключевых слов, принадлежащих указанной
			    группе.

	Пример: >
	
              :syntax keyword   Type   int long char
<
	{параметры} могут задаваться в любом месте строки. Они применяются ко
	всем перечисленным ключевым словам, в том числе к тем, которые
	перечислены до указания параметра. Нижеприведённые примеры полностью
	равноценны;
>
	      :syntax keyword   Type   contained int long char
	      :syntax keyword   Type   int long contained char
	      :syntax keyword   Type   int long char contained
<
	Если вы используете ключевое слово с необязательным окончанием, как
	например команды Ex в Vim, то можете поместить необязательные символы
	внутри [] для определения всех возможных вариантов в одном месте:
>
	      :syntax keyword   vimCommand	 ab[breviate] n[ext]
<
	Помните, что ключевое слово может быть опознано только в том случае,
	если все входящие в его состав символы перечислены в значении опции
	'iskeyword'. Если хотя бы один символ не включён в значение этой
	опции, то ключевое слово не будет распознаваться.
	Вы можете также использовать мультибайтные символы. Указание
	мультибайтных символов в значении опции 'iskeyword' не является
	обязательным.
	
	Ключевое слово всегда имеет более высокий приоритет, чем соответствие
	или область. Если данному слову соответствует несколько различных
	синтаксических элементов, то используется ключевое слово. Ключевые
	слова не могут быть вложены друг в друга и не могут содержать другие
	элементы.

	Обратите внимание, что вы не можете использовать ключевые слова,
	совпадающие с параметрами, включая те параметры, которые нельзя
	использовать в данной команде. В таких случаях следует применять
	синтаксический элемент соответствия.

	Максимальная длина ключевого слова составляет 80 символов.

	Одно и то же ключевое слово может быть определено несколько раз, в
	зависимости от контекста. Например, вы можете определить ключевое
	слово вне содержащего блока и применить к нему соответствующую группу
	подсветки, после чего определить ключевое слово как входящее в состав
	блока с применением другой группы подсветки:
>
	      :syn keyword vimCommand tag
	      :syn keyword vimSetting contained tag
<	
	В этом примере при обнаружении слова "tag" вне любого другого
	синтаксического элемента применяется группа подсветки "vimCommand".
	Если слово "tag" находится внутри синтаксического элемента
	"vimSetting", то применяется группа "vimSetting".


ОПРЕДЕЛЕНИЕ СООТВЕТСТВИЙ		      *:syn-match* *:syn-соответствие*

:sy[ntax] match {имя_группы} [{параметры}] [excludenl] {шаблон} [{параметры}]

	Данная команда определяет одно соответствие.

	{имя_группы}		Имя синтаксической группы, например "Comment".
	[{параметры}]		См. |:syn-параметры| ниже.
	[excludenl]		Позволяет не продолжать действие шаблона с
				символом конца строки "$" за внешнее
				соответствие или область. Это слово должно
				быть указано до шаблона. Подробнее см. раздел
				|:syn-excludenl|.
	{шаблон}		Шаблон поиска, определяющий соответствие.
	                        Подробнее см. |:syn-шаблон| ниже.
				Обратите внимание, что шаблону может
				соответствовать несколько строк, что делает
				соответствие зависимым от места, с которого
				Vim начинает поиск соответствия шаблону. Вы
				должны проследить, что синхронизация учитывает
				это обстоятельство.

	Пример (соответствие символьной константе): >
	      
	      :syntax match Character /'.'/hs=s+1,he=e-1
<

	                     *:syn-region* *:syn-start* *:syn-skip* *:syn-end*
ОПРЕДЕЛЕНИЕ ОБЛАСТИ	                          *E398* *E399* *:syn-область*

:sy[ntax] region {имя_группы} [{параметры}]
		[matchgroup={имя_группы}]
		[keepend]
		[extend]
		[excludenl]
		start={шаблон_начала} ..
		[skip={шаблон_пропуска}]
		end={шаблон_конца} ..
		[{параметры}]

	Эта команда определяет одну область, которая может занимать несколько
	строк текста.

	{имя_группы}		    Имя синтаксической группы, например
	                            "Comment".
	[{параметры}]		    См. |:syn-параметры| ниже.
	[matchgroup={имя_группы}]   Имя синтаксической группы, которая
				    применяется только к соответствиям
				    шаблонам начала и конца, указанным далее в
				    этой же команде. Эта группа не назначается
				    тексту, расположенному между
				    соответствиями шаблонам начала и конца.
				    Для отказа от использования отличной
				    группы для соответствий шаблонам начала и
				    конца используйте значение NONE.
				    См. |:syn-matchgroup|.
	keepend			    Указывает на недопустимость выхода
				    вложенных соответствий за пределы
				    соответствия шаблону конца. 
				    См. |:syn-keepend|.
	extend			    Переопределяет "keepend" для элемента, в
				    который вложена данная область.
				    См. |:syn-extend|.
	excludenl		    Позволяет не продолжать действие шаблона с
				    символом конца строки "$" за внешнее
				    соответствие или элемент. Полезно только
				    для шаблонов конца. Это слово должно быть
				    указано перед шаблонами, к которым оно
				    применяется.
				    См. |:syn-excludenl|.
	start={шаблон_начала}	    Шаблон поиска, определяющий начало
				    области. См. |:syn-шаблон| ниже.
	skip={шаблон_пропуска}	    Шаблон поиска, определяющий текст внутри
				    области, в котором не следует искать
				    соответствие шаблону конца. 
				    См. |:syn-шаблон| ниже.
	end={шаблон_конца}	    Шаблон поиска, определяющий конец
				    области. См. |:syn-шаблон| ниже.

	Пример:
>
	      :syntax region String   start=+"+  skip=+\\"+  end=+"+
<
	Шаблоны начала/пропуска/конца и параметры могут быть заданы в любом
	порядке. Шаблон пропуска может встречаться 0 или 1 раз. Вы должны
	указать один или более шаблонов начала и конца. Иными словами, вы
	можете не задавать шаблон пропуска, но должны задать хотя бы один
	шаблон начала и хотя бы один шаблон конца. Перед и после знака '='
	можно вставлять пробелы, хотя без них команда выглядит более опрятно.

	Если в команде содержится более одного шаблона начала, то достаточно
	соответствия хотя бы одному из указанных шаблонов. Другими словами,
	шаблоны начала объединяются с помощью операции ИЛИ. При работе
	используется последний совпадающий шаблон. То же самое касается и
	шаблонов конца.

	Поиск шаблона конца начинается сразу после конца соответствия шаблону
	начала. Смещения при этом не используются. Это в частности означает,
	что соответствие шаблону конца никогда не пересекается с соответствием
	шаблону начала.

	Шаблоны пропуска и конца могут задавать соответствия, включающие
	переносы строк, однако, поскольку поиск соответствия шаблону может
	начинаться с любой строки, результат может не всегда быть именно
	таким, как вам это нужно. Шаблон пропуска не позволяет избежать
	соответствия шаблону конца в следующей строке. Во избежание проблем
	старайтесь использовать однострочные шаблоны.

	Замечание: Решение о начале области принимается исключительно на
	основании соответствия шаблону начала области. Проверка наличия
	соответствующего шаблона конца области не производится. Поэтому,
	команды
>
		:syn region First  start="("  end=":"
		:syn region Second start="("  end=";"
<
	работать НЕ будут: Second всегда будет находится перед группой First
	(поскольку последний определённый шаблон имеет более высокий
	приоритет). В этом случае область Second будет продолжаться вплоть до
	следующего символа ';', независимо от наличия ':' перед ним. Исправить
	ситуацию можно с помощью элемента соответствия:
>
		:syn match First  "(\_.\{-}:"
		:syn match Second "(\_.\{-};"
<	
	Этот шаблон задаёт соответствие любому символу с помощью "\_." и затем
	повторяет это соответствие с помощью "\{-}" (минимально возможное
	количество раз).

							        *:syn-keepend*
	По умолчанию, вложенное соответствие может скрывать соответствие
	шаблону конца, что полезно при организации вложенных групп. Например,
	область, которая начинается с "{" и заканчивается "}" может содержать
	другую область. В этом случае символ "}" будет закрывать вложенную
	область, но не внешнюю область:

	    {		начало внешней области "{}"
		{	начало вложенной области "{}"
		}	конец вложенной области "{}"
	    }		конец внешней области "{}"

	Если вас не устраивает такое поведение, то вы можете применить
	параметр "keepend", который позволит при обнаружении соответствия
	шаблону конца внешней области также закрывать любой вложенный элемент.
	При этом становится невозможно вложить несколько одинаковых областей
	друг в друга, однако позволяет вложенным элементам подсвечивать части
	шаблона конца без пропуска этого соответствия с помощью шаблона конца.
	Например:
>
	:syn match  vimComment +"[^"]\+$+
	:syn region vimCommand start="set" end="$" contains=vimComment keepend	
<	
	Здесь "keepend" заставляет область vimCommand всегда завершаться в
	конце строки, даже если вложенная область vimComment включает
	соответствие <EOL>.

	Если "keepend" не применяется, то соответствие шаблону конца
	проверяется после каждого вложенного соответствия. При использовании
	"keepend" применяется первое соответствие шаблону конца, отсекая при
	этом любые вложенные соответствия.
	
							         *:syn-extend*
	Поведение "keepend" можно изменить с помощью параметра "extend".
	Когда элемент, определённый с параметром "extend" оказывается
	вложенным в элемент, использующий "keepend", параметр "keepend"
	внешнего элемента игнорируется, а вложенная область будет расширена.
	Эту особенность можно применять в тех случаях, когда необходимо
	обеспечить возможность расширения области только для некоторых
	вложенных элементов. Например:
>
   :syn region htmlRef start=+<a>+ end=+</a>+ keepend contains=htmlItem,htmlScript
   :syn match htmlItem +<[^>]*>+ contained
   :syn region htmlScript start=+<script+ end=+</script[^>]*>+ contained extend

<	В данном случае элемент htmlItem не позволяет элементу htmlRef
	продолжаться дальше, он используется только для подсветки элементов
	<>. В то же время, элемент htmlScript позволяет продолжить элемент
	htmlRef.

	Приведём ещё один пример:
>
   :syn region xmlFold start="<a>" end="</a>" fold transparent keepend extend
<

	Здесь определяется область с параметром "keepend", так что её конец не
	может быть изменён вложенными элементами, как при использовании
	"</a>", которое подсвечивается иначе. Однако, когда область xmlFold
	оказывается вложенной (включает саму себя), применяется параметр
	"extend" и в результате "</a>" вложенной области заканчивает только
	эту вложенную область, не оказывая влияния на внешнюю область.

							      *:syn-excludenl*
	Если шаблон соответствия или конца региона включает символ '$',
	которому соответствует конец строки, то в этом случае соответствующий
	элемент области будет продолжаться на следующей строке. Например,
	соответствие шаблону "\\$" (обратная косая черта в конце строки)
	продолжает область вместо того, чтобы закончить её в конце строки.
	Таково поведение по умолчанию. Если вас это не устраивает, то в вашем
	распоряжении имеется два способа изменить его:

	1. Используйте "keepend" для внешнего элемента. Это позволит удержать
	   все вложенные соответствия от выхода за пределы соответствия или
	   области. Этим можно пользоваться в тех случаях, когда ни один
	   вложенный элемент не должен расширять внешний элемент.
	   
	2. Используйте "excludenl" во вложенном элементе. Это позволит
	   удержать данное соответствие от расширения внешнего соответствия
	   или области. Этот вариант подходит в тех случаях, когда только
	   часть вложенных элементов не должна расширять границы внешнего
	   элемента. Слово "excludenl" следует указывать до шаблона, к
	   которому оно применяется.

							     *:syn-matchgroup*	
	"matchgroup" используется для подсветки соответствий шаблону начала
	и/или конца отличным от остальной части области способом. Например:
>
  :syntax region String matchgroup=Quote start=+"+  skip=+\\"+	end=+"+
<	
	В данном случае кавычки будут подсвечены с помощью группы "Quote", а
	текст между кавычками -- с помощью группы "String".
	Параметр "matchgroup" используется для всех последующих шаблонов
	начала и конца области, вплоть до определения следующей группы
	"matchgroup". Чтобы вновь отказаться от использования специфической
	matchgroup, применяйте "matchgroup=NONE".

	В шаблонах начала или конца, которые подсвечиваются с помощью
	"matchgroup", вложенные элементы области не используются. Это
	обстоятельство может быть полезным, чтобы избежать соответствия
	вложенным элементам в шаблонах начала и конца. При использовании
	"transparent" соответствия шаблонам начала и конца, подсвеченные с
	помощью "matchgroup", не затрагиваются.

	Приведём ещё один пример, который подсвечивает три уровня круглых
	скобок разными цветами:
>
   :sy region par1 matchgroup=par1 start=/(/ end=/)/ contains=par2
   :sy region par2 matchgroup=par2 start=/(/ end=/)/ contains=par3 contained
   :sy region par3 matchgroup=par3 start=/(/ end=/)/ contains=par1 contained
   :hi par1 ctermfg=red guifg=red
   :hi par2 ctermfg=blue guifg=blue
   :hi par3 ctermfg=darkgreen guifg=darkgreen

==============================================================================
6. Параметры команды :syntax 	             *:syn-arguments* *:syn-параметры*

В командах :syntax, определяющих синтаксические элементы, используется ряд
параметров, которые описаны ниже. Параметры можно задавать в любом порядке, в
том числе вперемешку с шаблонами.

Не все команды допускают использование всех параметров. В таблице ниже
приводятся параметры, которые не могут применяться во всех командах:

							         *E395* *E396*
		    contains  oneline	fold  display  extend ~
:syntax keyword		 -	 -	 -	 -	 -
:syntax match		да	 -	да	да	да
:syntax region		да	да	да	да	да

Нижеперечисленные параметры можно использовать во всех трёх командах:

	contained
	containedin
	nextgroup
	transparent
	skipwhite
	skipnl
	skipempty


contained						      *:syn-contained*

Параметр "contained" позволяет не распознавать соответствующий элемент на
самом верхнем уровне, включая его только в тех ситуациях, когда он упомянут в
поле "contains" другого соответствия. Например:
>
   :syntax keyword Todo    TODO    contained
   :syntax match   Comment "//.*"  contains=Todo


display							        *:syn-display*

Параметр "display" указывает, что данный элемент может быть пропущен, если
соответствующая подсветка не отображается на экране. Это позволяет ускорить
подсветку синтаксиса за счёт пропуска элементов, синтаксическое состояние
текста которых не отображается на экране.

В общем случае вы можете применять параметр "display" к элементам соответствия
и области, отвечающим следующим условиям:

- Элемент не продолжается после конца строки. Например, в синтаксисе языка C:
  область для комментария "/*" не может использовать параметр "display",
  поскольку она продолжается на следующей строке.
- Элемент не содержит элементов, которые продолжаются после конца строки или
  продолжают данный элемент на следующей строке.
- Элемент не изменяет размер ни одного из своих внешних элементов. Например, в
  синтаксисе языка C: соответствие шаблону "\\$" для команды препроцессора не
  может применять параметр "display", поскольку оно может сделать соответствие
  более коротким.
- Элемент не допускает существования соответствий для других элементов,
  которые в противном случае не обнаруживали бы соответствий, область действия
  которых простиралась бы слишком далеко. Например, в синтаксисе языка C:
  соответствие для комментария "//" не может использовать параметр "display",
  поскольку в этом случае срабатывало бы соответствие для "/*" внутри этого
  комментария, что приведёт к началу комментария, который будет продолжаться
  после конца строки.

Примеры для синтаксиса языка C, позволяющие использовать параметр "display":

- соответствие числу
- соответствие метке


transparent						    *:syn-transparent*

При использовании параметра "transparent" данный элемент не будет
подсвечиваться сам по себе, однако, он будет принимать на себя параметры
подсветки внешнего элемента. Это может оказаться полезным для синтаксических
элементов, которые не нуждаются в особом режиме подсветки, но применяются для
пропуска определённого фрагмента текста.

Параметр "contains=" также наследуется от внешнего элемента за исключением
ситуаций, когда параметр "contains" указан для самого элемента с параметром
"transparent". Чтобы избежать вложенности нежелательных элементов можно
использовать параметр "contains=NONE". Например, для подсветки слов в строках
за исключением "vim":
>
	:syn match myString /'[^']*'/ contains=myWord,myVim
	:syn match myWord   /\<[a-z]*\>/ contained
	:syn match myVim    /\<vim\>/ transparent contained contains=NONE
	:hi link myString String
	:hi link myWord   Comment
	
Поскольку соответствие "myVim" следует после "myWord", оно является
предпочтительным соответствием (последнее соответствие в той же самой позиции
переопределяет предыдущее соответствие). Параметр "transparent" применяет к
соответствию "myVim" те же самые параметры подсветки, что и для "myString",
однако оно не содержит других элементов. Если убрать параметр "contains=NONE",
то для элемента "myVim" применялся бы параметр "contains", унаследованный из
группы "myString", и группа "myWord" могла бы быть вложенной, что приводило бы
к её подсветке с использованием группы "Constant". Так происходит потому, что
вложенное соответствие не может использовать соответствие самой себе внутри
себя в той же самой позиции, так что соответствие "myVim" не переопределяет в
данном случае соответствие "myWord".

Текст с применением подсветки синтаксиса представляет собой многослойный пирог
вложенных элементов. Каждый вложенный элемент находится как бы сверху своего
внешнего элемента, что позволяет видеть его. Если вложенный элемент объявлен
прозрачным (с помощью параметра "transparent", вы можете смотреть сквозь него,
таким образом вы видите подсветку внешнего элемента. Посмотрите, как это
происходит:

      направление взгляда

       |  |  |  |  |  | 
       V  V  V	V  V  V

         xxxx	    yyy		другие вложенные элементы
      ....................	прозрачный вложенный элемент (transparent)
  =============================	первый элемент

Здесь 'x', 'y' и '=' представляют синтаксические элементы с применением
подсветки. Символами '.' представлена прозрачная синтаксическая группа.

В этом случае вы увидите на экране следующую картину:

  =======xxxx=======yyy========

Иными словами, получается, что вы смотрите сквозь прозрачную группу "....".


oneline							        *:syn-oneline*

Параметр "oneline" указывает, что область не должна пересекать границу конца
строки. Таким образом, область, заданная с данным параметром, должна полностью
помещаться в одной строке, однако, если область содержит вложенный элемент,
который занимает несколько строк, то она продолжается на следующей строке.
Вложенный элемент можно использовать для распознавания шаблона продолжения
строка. Тем не менее, соответствие шаблону "end" в любом случае должно быть
обнаружено в первой строке, иначе область просто не будет начата.

Если шаблон начала области включает "\n" для обнаружения соответствия концу
строки, то шаблон конца должен быть найден в той же самой строке, где
заканчивается шаблон начала. Шаблон конца также может включать конец строки.
Таким образом, параметр "oneline" обозначает, что конец шаблона начала и
начало шаблона конца должны находиться в одной и той же строке. Это поведение
нельзя изменить с помощью шаблона пропуска, включающего символ переноса
строки.


fold					            *:syn-fold* *:syn-складки*

Параметр "fold" позволяет увеличить уровень вложенности складки для
соответствующего элемента на единицу.
Например:
>
   :syn region myFold start="{" end="}" transparent fold
   :syn sync fromstart
   :set foldmethod=syntax
   
В данном случае каждый блок {} образует отдельную складку.

Складка начинается на строке, в которой начинается соответствующий элемент, и
заканчивается на строке, где заканчивается этот элемент. Если начало и конец
находятся в одной и той же строке, то складка не образуется. Опция
'foldnestmax' позволяет ограничить вложенность синтаксических складок.
{доступно только в том случае, если Vim скомпилирован с особенностью 
|+folding|}


			    *:syn-contains* *E405* *E406* *E407* *E408* *E409*
contains={имя_группы},..

Параметр "contains" содержит список имён синтаксических групп. Указанные
группы могут быть вложены в данную группу и могут выходить за пределы конца
области данной группы. Это делает возможным рекурсивное вложение соответствий
и областей. Если параметр "contains" не задан, то данный элемент не будет
включать другие группы. Группы, перечисленные в данном параметре, не
обязательно должны быть определены до использования в этом контексте.

contains=ALL
		Если единственным элементом в списке contains является "ALL",
		то внутри данного элемента может быть вложена любая группа.

contains=ALLBUT,{имя_группы},..
		Если в качестве первого элемента в списке contains
		используется "ALLBUT", то внутри данного элемента может быть
		вложена любая группа, кроме указанных в списке. Например:
>
  :syntax region Block start="{" end="}" ... contains=ALLBUT,Function

contains=TOP
		Если в качестве первого элемента в списке contains
		используется "TOP", то внутри данного элемента могут быть
		вложены любые группы, определённые без параметра "contained".

contains=TOP,{имя_группы},..
		То же, что и "TOP", за исключением групп, перечисленных далее
		в списке.

contains=CONTAINED
		Если в качестве первого элемента в списке contains
		используется "CONTAINED", то внутри данного элемента могут
		быть вложены любые группы, определённые с параметром
		"contained".

contains=CONTAINED,{имя_группы},..
		То же, что и "CONTAINED", за исключением групп, перечисленных
		далее в списке.


В качестве {имени_группы} в списке параметра "contains" можно использовать
шаблон. Все имена групп, соответствующие шаблону, будут включены в список
(или исключены из списка в том случае, если применяется "ALLBUT"). Шаблон не
может включать пробелы или символ ','. Например:
>
   ... contains=Comment.*,Keyw[0-3]

Соответствие шаблону проверяется в момент выполнения команды syntax, поэтому
группы, определённые позже не могут быть включены в соответствие. Кроме того,
если в данной команде syntax определяется новая группа, то она также не будет
включена в соответствие. Будьте внимательны: при помещении команд syntax в
отдельном файле вы не можете полагаться на то, что группы НЕ определены,
поскольку данный сценарий мог быть уже прочитан раннее, а команда ":syn clear"
не удаляет имена групп.

Соответствия вложенным группам могут также находится в шаблонах конца и начала
области. Если это не желательно, то можно применять параметр "matchgroup", 
см. раздел |:syn-matchgroup|. Смещения "ms=" и "me=" могут применяться для
изменения области, в которой обнаружены соответствия вложенным элементам.
Обратите внимание, что это также может приводить к ограничению подсвечиваемой
области.


containedin={имя_группы}...				    *:syn-containedin*

Параметр "containedin" также использует список имён синтаксических групп. Этот
параметр указывает, что данная группа может быть начата внутри перечисленных
групп. Иначе говоря, поведение будет таким же, как если бы внешний элемент был
определён с параметром "contains=", в котором был бы указан данный элемент.

{имя_группы}... применяется точно так же, как и в параметре "contains",
согласно приведённому выше описанию.

Данный параметр полезен при последующем добавлении синтаксического элемента.
Вы можете разрешить вложение элемента внутри существующего элемента без
необходимости изменения определения этого элемента. Например, для подсветки
слова в комментарии C после загрузки сценария подсветки синтаксиса языка C
можно использовать команду:
>
	:syn keyword myword HELP containedin=cComment contained

Обратите внимание, что здесь также используется параметр "contained", чтобы
избежать соответствия элементу на верхнем уровне.

Соответствия элементам, определённым с параметром "containedin" добавляются к
другим местам, где может появляться данный элемент. Кроме того, вы можете
добавлять параметр "contains", как обычно. Не забывайте, что ключевые слова
никогда не содержат других элементов, поэтому добавление имён групп ключевых
слов в параметр "containedin" работать не будет.


nextgroup={имя_группы},..				      *:syn-nextgroup*

Параметр "nextgroup" использует список имён синтаксических групп, разделённых
запятыми (точно так же, как и параметр "contains", так что вы также можете
применять и шаблоны).

При использовании параметра "nextgroup" перечисленные синтаксические группы
будут по очереди проверяться на наличие соответствия после того, как
заканчивается данная область или соответствие. Если ни одна из перечисленных
групп не совпадает со следующей группой, то подсветка синтаксиса выполняется
как обычно. В противном случае будет применяться данная группа, даже если она
не упомянута в списке "contains" текущей группы. Иными словами, указанная
группа получает приоритет над остальными группами. Например:
>
   :syntax match  ccFoobar  "Foo.\{-}Bar"  contains=ccFoo
   :syntax match  ccFoo     "Foo"	    contained nextgroup=ccFiller
   :syntax region ccFiller  start="."  matchgroup=ccBar  end="Bar"  contained

В данном случае "Foo" и "Bar" будут подсвечены по разному, если "Bar" следует
после "Foo". В строке текста, приведённой ниже, "f" указывает на применение
подсветки ccFoo, а "bbb" на применение подсветки ccBar.
>
   Foo asdfasd Bar asdf Foo asdf Bar asdf
   fff	       bbb	fff	 bbb

Обратите внимание на использование ".\{-}" для пропуска минимально возможного
фрагмента текста до следующего появления Bar. Если использовать ".*", то
"asdf" между "Bar" и "Foo" подсвечивались бы в соответствии с правилами группы
"ccFoobar", поскольку соответствие ccFoobar включало бы первое "Foo" и
последнее "Bar" в этой строке (см. |шаблон|).

skipwhite						      *:syn-skipwhite*
skipnl							         *:syn-skipnl*
skipempty						      *:syn-skipempty*

Эти параметры используются только в сочетании с "nextgroup". Они применяются
для того, чтобы позволить обнаружение соответствия для следующей группы после
пропуска определённого фрагмента текста:

	skipwhite	пропускать пробелы и символы табуляции
	skipnl		пропускать конец строки
	skipempty	пропускать пустые строки (подразумевает также
	                "skipnl")

При использовании параметра "skipwhite" пробелы пропускаются только в том
случае, если отсутствует следующая группа, которой соответствуют пробельные
символы.

При использовании "skipnl" соответствие следующей группе может быть найдено на
следующей строке. Это происходит только в том случае, если текущий элемент
заканчивается с концом текущей строки! Если параметр "skipnl" не задан, то
следующая группа будет обнаружена только после данного элемента в той же самой
строке.

При пропуске фрагмента текста в поисках следующей группы, соответствия другим
группам игнорируются. Если ни одна соответствие ни для одной из следующих
групп не было обнаружено, то производится повторная проверка соответствия
элементам в пропущенном фрагменте. Иными словами, соответствия следующей
группе и пропуск пробелов и символов <EOL> имеют более высокий приоритет, чем
другие элементы.

Пример: 
>
  :syn match ifstart "\<if.*"	  nextgroup=ifline skipwhite skipempty
  :syn match ifline  "[^ \t].*" nextgroup=ifline skipwhite skipempty contained
  :syn match ifline  "endif"	contained

Обратите внимание, что шаблону "[^ \t].*" соответствует любой фрагмент текста,
не включающий пробельные символы, в том числе "endif". По этой причине
соответствие "endif" определено в последнюю очередь, чтобы обеспечить его
приоритет.

Заметим, что этот пример не будет работать для вложенных "if" -- вам
потребуется для этого добавить параметры "contains", которые не были указаны
для упрощения приведённого примера.

==============================================================================
7. Шаблоны в команде syntax         *:syn-pattern* *E401* *E402* *:syn-шаблон*

Шаблоны, используемые в команде syntax, должны быть заключены между двумя
одинаковыми символами, как в команде ":s". Чаще всего для этой цели
применяется двойная кавычка, однако, если двойная кавычка используется внутри
шаблона, вы можете использовать любой другой символ, который не задействован
внутри шаблона. Например:
>
  :syntax region Comment  start="/\*"  end="\*/"
  :syntax region String   start=+"+    end=+"+	 skip=+\\"+

Подробная информация о шаблонах приводится в разделе |шаблон|. Шаблоны,
применяемые в команде syntax всегда рассматриваются как "волшебные",
независимо от действительного значения опции 'magic'. Кроме того, при разборе
этих шаблонов считается, что флаг 'l' отсутствует в значении опции
'cpoptions'. Такое поведение принято для обеспечения переносимости файлов
со сценариями подсветки синтаксиса независимо от настройки опций 'compatible'
и 'magic'.

Постарайтесь избегать использования шаблонов, которым могут соответствовать
пустые строки, например "[a-z]*". Такие шаблоны существенно снижают скорость
подсветки, поскольку соответствия им могут быть обнаружены в любом месте.

				  *:syn-pattern-offset* *:syn-шаблон-смещение*
После шаблона может быть задано символьное смещение, что полезно для изменения
подсвечиваемой области или изменения области текста, включаемой в соответствие
или область (что может иметь значение только при попытке обнаружения
соответствия для других элементов). В обоих случаях смещение вычисляется
относительно фрагмента текста, соответствующего шаблону. Символьное смещение
в шаблоне пропуска текста можно применять для указания места, с которого
следует выполнять поиск соответствия шаблону конца.

Смещение указывается в формате "{что}={формат}", где в качестве {что}
используется одна из семи нижеперечисленных строк:

ms	Начало соответствия Смещение для начала соответствия шаблону
me	Конец соответствия  Смещение для конца соответствия шаблону
hs	Начало подсветки    Смещение для начала подсветки
he	Конец подсветки     Смещение для конца подсветки
rs	Начало области	    Смещение для начала области
re	Конец области	    Смещение для конца области
lc	Вводящий контекст   Смещение после "вводящего контекста" шаблона

В качестве {смещения} применяется:

s			    начало соответствия шаблону
s+{число}		    начало соответствия шаблону плюс указанное {число}
			    символов справа
s-{число}		    начало соответствия шаблону плюс указанное {число}
			    символов слева
e			    конец соответствия шаблону
e+{число}		    конец соответствия шаблону плюс указанное {число}
			    символов справа
e-{число}		    конец соответствия шаблону плюс указанное {число}
			    символов слева
{число}	(только для "lc")   начинать соответствие на указанное {число}
			    символов левее

Примеры: "ms=s+1", "hs=e-2", "lc=3".

Хотя все смещения могут задаваться после любого шаблона, они не всегда имеют
смысл. В нижеприведённой таблице показано в каких случаях тот или иной шаблон
действительно будет использован.

			ms   me   hs   he   rs   re   lc ~
элемент соответствия	да   да   да   да   -    -    да
начало области		да   -    да   -    да   -    да
пропуск в области       -    да   -    -    -    -    да
конец области           -    да   -    да   -    да   да

Смещения можно сочетать, соединяя их с помощью ','. Например:
>
  :syn match String  /"[^"]*"/hs=s+1,he=e-1
<
    текст про "цололо"
	       ^^^^^^		подсвечено

Примечания:

- Между шаблоном и символьными смещениями не должно быть пробельных символов.
- Область подсветки не может находиться за пределами текста, соответствующего
  шаблону.
- Использование отрицательного смещения в шаблоне конца может работать не во
  всех случаях, поскольку соответствие шаблону конца может быть обнаружено уже
  после того, как применение подсветки прекращено.
- Начало соответствия не может находиться в строке, отличной от строки, в
  которой обнаружено соответствие шаблону. Конструкция "a\nb"ms=e работать не
  будет. Однако, вы можете начать подсветку в другой строке, например
  "a\nb"hs=e.

Пример (поиск соответствия для комментариев без применения подсветки 
к /* и */):
>
  :syntax region Comment start="/\*"hs=e+1 end="\*/"he=s-1
<
	/* это комментарий */
	  ^^^^^^^^^^^^^^^^^	  подсвечено

Более сложный пример:
>
  :syn region Exa matchgroup=Foo start="foo"hs=s+2,rs=e+2 matchgroup=Bar end="bar"me=e-1,he=e-1,re=s-1
<
	 abcfoostringbarabc
	    mmmmmmmmmmm	    соответствие
	      ssrrrreee	    начало/область/конец подсветки ("Foo", "Exa" и "Bar")


Вводящий контекст		       *:syn-lc* *:syn-leading* *:syn-context*

Замечание: эта особенность является устаревшей и включена только для
обеспечения совместимости с предыдущими версиями Vim. В современных версиях
рекомендуется вместо неё применять шаблоны с конструкцией |/\@<=|.

Смещение "lc" указывает на вводящий контекст -- часть шаблона, которая должна
присутствовать в тексте, но не считается частью соответствия. Смещение "lc=n"
заставляет Vim отступать назад на n колонок перед тем, как определить
соответствие шаблону, что позволяет использовать символы, которые уже были
задействованы в соответствиях другим шаблонам, в качестве вводящего контекста
для данного соответствия. Это может, например, применяться для указания на
отсутствие экранирующего символа перед соответствием:
>
  :syn match ZNoBackslash "[^\\]z"ms=s+1
  :syn match WNoBackslash "[^\\]w"lc=1
  :syn match Underline "_\+"
<
	  ___zzzz ___wwww
	  ^^^	  ^^^	  соответствует Underline
	      ^ ^	  соответствует ZNoBackslash
		     ^^^^ соответствует WNoBackslash

Смещение "ms" автоматически устанавливается равным той же величине, что и
смещение "lc", если смещение "ms" не задано явным образом.


Многострочные шаблоны		*:syn-multi-line* *:syn-многострочные_шаблоны*

Шаблоны могут включать "\n" для обозначения конца строки. За рядом исключений
это работает так, как должно.

При использовании шаблона начала со смещением, начало соответствия не может
начинаться на следующей строке. Однако, подсветка может быть начата на
следующей строке.

Шаблон пропуска может включать "\n", однако поиск шаблона конца будет
продолжен на первом символе следующей строки даже если этот соответствие этому
символу определено шаблоном пропуска. Так происходит потому, что обновление
экрана может происходить на любой строке в середине области, а проверка на
начало соответствия шаблону пропуска в предыдущей строке не производится.
Например, если используется шаблон пропуска "a\nb", а в качестве шаблона конца
используется "b", то соответствие шаблону конца будет найдено во второй строке
в следующем примере:
>
	 x x a
	 b x x

В общем случае, это означает, что в шаблоне пропуска не следует задавать
соответствие каким-либо символам после "\n".


Внешние соответствия		  *:syn-ext-match* *:syn-внешнее_соответствие*

В шаблонах области допускается использование следующих дополнительных
элементов регулярных выражений:

						   */\z(* */\z(\)* *E50* *E52*
    \z(\)	Помечает подвыражение как "внешнее", т.е. на него можно
                ссылаться из другого шаблона. В настоящий момент используется
		только в шаблоне начала синтаксической области.

					    */\z1* */\z2* */\z3* */\z4* */\z5*
    \z1  ...  \z9		       */\z6* */\z7* */\z8* */\z9* *E66* *E67*
		Элементу соответствует та же строка, что и отвечающая
		соответствующему подвыражению в предыдущем шаблоне начала
		области.

Иногда возникают ситуации, когда шаблоны начала и конца области должны
использовать общее подвыражение. В качестве примера можно привести так
называемый здесь-документ ("heredoc") в языке Perl и многих оболочках Unix.
Такого эффекта можно достичь с помощью специального элемента регулярных
выражений "\z", который помечает подвыражение как "внешнее", в том смысле, что
на него можно сослаться извне шаблона, в котором он был определён. Например,
так:
>
  :syn region hereDoc start="<<\z(\I\i*\)" end="^\z1$"

Как вы можете увидеть, \z несёт двойную функцию. В шаблоне начала этот элемент
помечает подвыражение "\(\I\i*\)" как внешнее; в шаблоне конца он применяется
для замены обратной ссылки \1 на внешнюю ссылку, связанную с первым
подвыражением в шаблоне начала. Внешние ссылки также могут использоваться 
и в шаблонах пропуска:
>
  :syn region foo start="начало \(\I\i*\)" skip="не конец \z1" end="конец \z1"

Обратите внимание, что обычные и внешние подвыражения никак не пересекаются и
нумеруются отдельно друг от друга; например, если шаблон "\z(..\)\(..\)"
применяется к строке "aabb", то \1 будет ссылаться на "bb", а \z1 будет
ссылаться на "aa".

Также заметьте, что внешние подвыражения не могут быть доступны в качестве
обратных ссылок в том же самом шаблоне, подобно обычным подвыражениям. Если вы
хотите использовать какое либо подвыражение как в качестве внешнего, так и в
качестве обычного подвыражения, то вы можете вложить один элемент в другой,
например: "\(\z(...\)\)".

Отметим также, что вы можете использовать таким образом только соответствия,
расположенные а пределах одной строки. Сделать ссылку на многострочные
соответствия не получится.

==============================================================================
8. Синтаксические кластеры               *:syn-cluster* *E400* *:syn-кластеры*

:sy[ntax] cluster {имя_кластера} [contains={имя_группы}..]
				 [add={имя_группы}..]
				 [remove={имя_группы}..]

Данная команда позволяет вам собрать несколько синтаксических групп в общий
кластер с одним именем.

	contains={имя_группы}..
		Определяет содержание кластера перечисленными в списке
		группами.
	add={имя_группы}..
		Указанные группы добавляются к кластеру.
	remove={имя_группы}..
	        Указанные группы удаляются из кластера.

Кластер, определённый с помощью данной команды, может использоваться вместо
имени группы в списках, применяемых в параметрах contains=.., nextgroup=..,
add=.. или remove=.., если его имя предваряется приставкой "@". Вы можете
использовать то же самое соглашение для неявного объявления кластера даже до
того, как определено его содержание.

Пример:
>
   :syntax match Thing "# [^#]\+ #" contains=@ThingMembers
   :syntax cluster ThingMembers contains=ThingMember1,ThingMember2

Как подсказывает предыдущий пример, изменения в составе кластера проверяются
непосредственно перед использованием кластера:
>
   :syntax keyword A aaa
   :syntax keyword B bbb
   :syntax cluster AandB contains=A
   :syntax match Stuff "( aaa bbb )" contains=@AandB
   :syntax cluster AandB add=B	  " теперь оба ключевых слова входят в
                                  " соответствие Stuff

Это также относится и к вложенным кластерам:
>
   :syntax keyword A aaa
   :syntax keyword B bbb
   :syntax cluster SmallGroup contains=B
   :syntax cluster BigGroup contains=A,@SmallGroup
   :syntax match Stuff "( aaa bbb )" contains=@BigGroup
   :syntax cluster BigGroup remove=B	" не имеет эффекта, поскольку B не
                                        " входит в BigGroup
   :syntax cluster SmallGroup remove=B	" теперь bbb не входит в соответствие 
				        " Stuff

==============================================================================
                                                         *:syn-include* *E397*
9. Подключение других сценариев синтаксиса                  *:syn-подключение*

Часто оказывается полезным включить файл подсветки синтаксиса для одного языка
в файл подсветки синтаксиса для другого, связанного с ним, языка. 
В зависимости от характера этой взаимосвязи такое подключение можно
реализовать двумя различными способами:

	- Если синтаксические элементы верхнего уровня в подключаемом сценарии
	  подсветки синтаксиса могут использоваться на верхнем уровне в
	  сценарии, из которого выполняется подключение, то достаточно просто
	  воспользоваться командой |:runtime|:
>
  " В cpp.vim:
  :runtime! syntax/c.vim
  :unlet b:current_syntax

<	- Если синтаксические элементы верхнего уровня в подключаемом сценарии
	  должны быть вложены в определённую область в сценарии, из которого
	  выполняется подключение, то вы можете использовать команду 
	  ":syntax include":

:sy[ntax] include [@{имя_списка_групп}] {имя_файла}

	  Все синтаксические элементы, определённые в подключаемом сценарии,
	  будет добавлены с флагом "contained". Кроме того, если указан список
	  групп, то все синтаксические элементы верхнего уровня в подключаемом
	  файле будут добавлены в указанный список.
>
   " В perl.vim:
   :syntax include @Pod <sfile>:p:h/pod.vim
   :syntax region perlPOD start="^=head" end="^=cut" contains=@Pod
<
	  Если {имя_файла} задано в виде абсолютного пути (т.е., начинается с
	  "/", "c:", "$VAR" или "<sfile>"), то будет считан указанный файл.
	  При использовании относительного пути (например, "syntax/pod.vim"),
	  поиск указанного файла будет осуществляться в каталогах,
	  перечисленных в значении опции 'runtimepath'. Все найденные файлы
	  будут загружены. Мы рекомендуем использовать относительные пути,
	  поскольку это позволяет пользователю заменять подключаемый файл
	  собственной версией без необходимости внесения изменений в файл
	  сценария, в котором выполняется команда ":syn include".

==============================================================================
10. Синхронизация	        *:syn-sync* *E403* *E404* *:syn-синхронизация*

Поскольку Vim должен быть способен начинать обновление экрана с любой строки
документа, ему требуется знать состояние механизма подсветки синтаксиса в
точке начала обновления.

:sy[ntax] sync [ccomment [имя_группы] | minlines={N} | ...]

Всего существует четыре способа синхронизации:

1. Анализ синтаксиса всегда начинается с начала файла.
   |:syn-sync-first|
2. Анализ синтаксиса выполняется на основании комментариев в стиле языка C.
   Vim понимает, как работают комментарии C и способен установить, находится
   начало текущей строки внутри или снаружи комментария.
   |:syn-sync-second|
3. Анализ синтаксиса выполняется при помощи просмотра некоторого количества
   строк, расположенных перед текущей строкой.
   |:syn-sync-third|
4. Для выполнения анализа синтаксиса производится поиск в обратном направлении
   соответствия определённому шаблону, с которого будет выполняться
   синхронизация.
   |:syn-sync-fourth|

				     *:syn-sync-maxlines* *:syn-sync-minlines*
В трёх последних методах диапазон строк, где может быть начат анализ
синтаксиса, ограничивается параметрами "minlines" и "maxlines".

Если задан параметр "minlines={N}", то анализ синтаксиса всегда начинается как
минимум за N строк до первой видимой на экране строки. Это можно использовать,
если анализ синтаксиса требует определённое количество известных строк
контекста или когда невозможно использовать синхронизацию.

Если задан параметр "maxlines={N}", то количество строк, которые будут
просматриваться в обратном направлении в поисках комментариев или соответствия
шаблону для синхронизации, ограничивается значением N (с добавлением значения
"minlines"). Этот параметр полезен в тех ситуациях, когда вы работаете на
медленном компьютере и в вашем тексте не так много мест, с которых можно
начать синхронизацию. Например:
>
   :syntax sync ccomment maxlines=500
<
						        *:syn-sync-linebreaks*
При использовании шаблона, которому соответствует несколько строк, изменение в
одной строке может привести к ситуации, когда соответствие шаблону в
предыдущей строке нарушается. В этом случае синхронизация должна начинаться до
строки, в которую было внесено изменение. Количество таких строк может быть
задано с помощью параметра "linebreaks". Например, если шаблон может включать
один символ переноса строки, используйте
>
   :syntax sync linebreaks=1

В результате выполнения этой команды обновление всегда будет происходить не
менее чем за одну строку до места внесения изменений. По умолчанию
используется значение "linebreaks", равное нулю. Обычно значение параметра
"minlines" бывает больше, чем значение "linebreaks".


Первый метод синхронизации:                                  *:syn-sync-first*
>
   :syntax sync fromstart

Анализ синтаксиса выполняется от начала файла. Хотя этот метод позволяет
всегда получать точную подсветку синтаксиса, на длинных файлах он работает
медленно. Vim помещает уже разобранный текст в специальный буфер, так что
задержки в отображении текста наиболее заметны при первоначальной загрузке.
Однако, при внесении изменений в текст анализ синтаксиса должен быть
произведён заново, в худшем случае -- вплоть до самого конца файла.

Использование "fromstart" равноценно применению параметра "minlines" с очень
большим значением.


Второй метод синхронизации:	       *:syn-sync-second* *:syn-sync-ccomment*

При использовании второго метода синхронизации можно задавать только параметр
"ccomment". Например:
>
   :syntax sync ccomment

Если Vim обнаруживает, что первая строка, видимая на экране, находится внутри
комментария в стиле языка C, то будет применяться последний синтаксический
элемент области с именем группы "Comment". Это предъявляет требование
существования области с именем группы "Comment"! Вы можете также указать
другое имя группы, например:
>
   :syntax sync ccomment javaComment

В данном случае для обнаруженной области комментария в стиле языка C будет
применяться последний элемент, определённый с помощью команды 
"syn region javaComment". Данный метод работает как полагается только в том
случае, если в качестве шаблона начала области используется "\/*", а в
качестве шаблона конца области -- "*\/".

Параметр "maxlines" может применяться для ограничения числа строк для поиска.
Параметр "minlines" может применяться для указания минимального количества
строк перед первой отображаемой на экране строкой, в которых происходит поиск
(например, если имеется некая синтаксическая конструкция, которая занимает
всего несколько строк, но синхронизация по которой является затруднительной).

Замечание: Синхронизация по комментариям в стиле языка C не работает как
следует, если в тексте используются строковые константы, занимающие несколько
строк и содержащие символы "*/". Поскольку использование строковых констант,
которые занимают несколько строк, является плохим стилем форматирования
программного кода (некоторые компиляторы выводят в таких случаях
предупреждение), а вероятность появления "*/" внутри комментария мала, данное
ограничение практически не влияет на работу.


Третий метод синхронизации:			             *:syn-sync-third*

При использовании третьего метода синхронизации требуется указание только
параметра "minlines={N}". Vim будет вычитать указанное число {N} из номера
первой отображаемой строки и анализ синтаксиса будет происходить начиная со
строки с данным номером. Это приводит к тому, что Vim будет анализировать
синтаксиса {N} дополнительных строк, что может немного замедлять работу.
Например:
>
   :syntax sync minlines=50

Параметр "lines", который использовался в старых версиях Vim, полностью
равнозначен параметру "minlines".


Четвёртый метод синхронизации:				    *:syn-sync-fourth*

Идея четвёртого метода заключается в синхронизации по концовкам небольшого
числа определённых областей, которые называются шаблоном синхронизации.
Поскольку только области могут занимать несколько строк, мы можем установить в
каком синтаксическом элементе находится та или иная строка по концу
определённой области. Поиск соответствия начинается со строки, непосредственно
предшествующей строке, в которой происходит обновление. Далее поиск
продолжается к началу файла.

Поиск происходит почти так, как при поиске несинхронизирующих синтаксических
элементов. Вы можете использовать вложенные соответствия, следующие группы 
и т.д. Следует однако иметь в виду, что имеется ряд отличий:

- Вы не можете использовать ключевые слова.
- Синтаксические элементы с параметром "sync" образуют совершенно отдельную
  группу синтаксических элементов. Вы не можете смешивать синхронизирующие
  и несинхронизирующие группы.
- Поиск происходит в обратном, а не в прямом направлении, к началу буфера,
  строка за строкой.
- Вы можете задать шаблон для продолжения строки. Такой шаблон применяется для
  определения группы строк, поиск в которых должен происходить так, как если
  бы это была одна строка. Иными словами, поиск соответствия определённому
  элементу начинается в первой строке группы строк, соединённых шаблоном
  продолжения строки.
- Использование "nextgroup" или "contains" ограничено пределами одной строки
  (или группы строк, соединённых элементом продолжения строки).
- Область должна начинаться и заканчиваться в одной и той же строке (или
  группе строк, соединённых элементом продолжения строки). В противном случае
  считается, что конец области находится в конце строки, или в конце группы
  строк, соединённых элементом продолжения строки.
- При обнаружении соответствия шаблону синхронизации выполняется поиск
  следующего соответствия в остальной части строки (или группе строк,
  соединённых элементом продолжения строки). Для синхронизации используется
  последнее найденное соответствие. Это полезно в тех случаях, когда строка
  может содержать как начало, так и конец области (например, в комментарии в
  стиле языка C вроде /* этого */, применяется последний обнаруженный
  элемент "*/").

Существует два способа использовать найденное соответствие шаблону
синхронизации:

1. Анализ синтаксиса для выполнения подсветки начинается в той точке, где
   начинается обновление (т.е. с точки, откуда начинается поиск соответствия
   шаблону синхронизации). При этом следует использовать синтаксическую
   группу, которая действительно может находиться в этом месте. Этот способ
   хорошо работает в тех случаях, когда многострочные области не могут
   содержать других областей.
   
2. Анализ синтаксиса для выполнения подсветки продолжается сразу после
   обнаружения соответствия. При этом следует использовать синтаксическую
   группу, которая действительно может находиться в точке после обнаружения
   соответствия. Этот способ применяется в тех случаях, когда предыдущий
   способ работает не совсем хорошо. Данный способ значительно более
   медленный, поскольку приходится анализировать значительно больший фрагмент
   текста.

Вы можете одновременно использовать оба типа шаблонов синхронизации.

Помимо шаблонов синхронизации можно указывать и другие области и соответствия,
чтобы избегать обнаружения нежелательных соответствий.

[Причина, по которой шаблоны синхронизации задаются отдельно, связана с тем,
что, как правило, поиск точки синхронизации значительно проще, чем выполнение
подсветки. Уменьшение количества шаблонов приводит к значительному ускорению
работы.]

					    *syn-sync-grouphere* *E393* *E394*

:syntax sync match {имя_группы_синхронизации} grouphere {имя_группы} "шаблон" ..

	Команда определяет соответствие, которое применяется для
	синхронизации. {имя_группы} указывает на имя синтаксической группы,
	которая следует сразу после соответствия. Анализ синтаксиса для
	выполнения подсветки начинается сразу после соответствия. Область для
	группы с указанным {именем_группы} должна существовать. При этом будет
	использоваться первая определённая область. Если после соответствия не
	следует никакая синтаксическая группа, то в качестве {имени_группы}
	можно использовать "NONE".

						         *syn-sync-groupthere*
:syntax sync match {имя_группы_синхронизации} groupthere {имя_группы} "шаблон" ..

	То же, что и "grouphere", но {имя_группы} указывает на имя
	синтаксической группы, которая должна использоваться в начале строки,
	где начинается поиск точки синхронизации. При этом подразумевается,
	что в тексте между соответствием и началом поиска соответствия шаблону
	синхронизации нет изменений в подсветке синтаксиса. Например, в C вы
	можете выполнять поиск в обратном направлении элементов "/*" и "*/".
	Если элемент "/*" найден первым, то вы можете быть уверены, что
	находитесь внутри комментария, поэтому в качестве "groupthere"
	используется "cComment". Если первым обнаружен элемент "*/", то вы
	знаете, что находитесь за пределами комментария и в этом случае в
	качестве "groupthere" используется "NONE". (В реальной жизни всё
	обстоит немного сложнее, поскольку "/*" и "*/" могут встречаться
	внутри строки. Мы предлагаем вам самостоятельно решить эту проблему 
	в качестве упражнения).

    :syntax sync match ..
    :syntax sync region ..

	Без параметра "groupthere".  Команда определяет область, которая
	пропускается при поиске точки синхронизации.

    :syntax sync linecont {шаблон}

	Если соответствие указанному {шаблону} встречается в строке, то
	считается, что строка продолжается на следующей строки. Иными словами,
	с точки зрения поиска точки синхронизации эти строки являются одной
	строкой.

Если также применяется параметр "maxlines={N}", то число строк, в которых
происходит поиск соответствия, ограничивается указанным числом N. Это
оказывается полезным на медленных компьютерах, если в тексте используется
немного элементов для синхронизации. Например:
>
   :syntax sync maxlines=100

Вы также можете очистить все настройки синхронизации по команде
>
   :syntax sync clear

Вы можете удалить определённые шаблоны синхронизации с помощью команды
>
   :syntax sync clear {имя_группы_синхронизации} ..

==============================================================================
11. Вывод списка синтаксических элементов   *:syntax* *:sy* *:syn* *:syn-list*

Список всех синтаксических элементов выводится по команде
>
    :sy[ntax] [list]

Чтобы показать синтаксические элементы, входящие в одну из синтаксических
групп, используйте команду
>
    :sy[ntax] list {имя_группы}
<
                                                                        *E392*
Для вывода списка синтаксических групп, входящих в синтаксический кластер,
применяется команда
>
    :sy[ntax] list @{имя_кластера}

Параметры команды ":syntax" объясняются выше.

Обратите внимание, что команда ":syntax" может сокращаться до ":sy", хотя чаще
всего используется сокращение ":syn", поскольку это делает код более понятным.

==============================================================================
12. Команда подсветки :highlight        *:highlight* *:hi* *E28* *E411* *E415*

Имеется три разных типа групп подсветки:

- Группы, применяемые для определённых языков. Такие группы начинаются с имени
  языка. Многие группы этого типа определяются без параметров; вместо этого
  они связываются с группами второго типа.
- Группы, используемые для всех языков.
- Группы, используемые только для работы с опцией 'highlight'.

							          *hitest.vim*
Вы можете посмотреть все активные в настоящий момент группы с помощью команды
>
    :so $VIMRUNTIME/syntax/hitest.vim

При выполнении этого сценария открывается новое окно, в котором отображаются
имена всех групп, подсвеченные соответствующими цветами.

						 *:colo* *:colorscheme* *E185*
:colo[rscheme] {имя}	Команда выполняет загрузку цветовой схемы с указанным
			{именем}. При этом происходит поиск файла с именем
			"colors/{имя}.vim" в каталогах, перечисленных в
			значении опции 'runtimepath'. После обнаружения
			первого найденного файла с описанием цветовой схемы,
			он будет загружен.
			Чтобы посмотреть имя активной в настоящий момент
			цветовой схемы, если такая определена, используйте
			команду
>
				:echo g:colors_name
<			
			Данная команда не работает рекурсивно, поэтому вы не
			можете использовать ":colorscheme" в сценарии
			определения цветовой схемы.

:hi[ghlight]		Команда выводит список всех активных групп подсветки с
			включёнными параметрами.

:hi[ghlight] {имя_группы}
			Команда показывает указанную группу подсветки.

:hi[ghlight] clear	Команда используется для сброса подсветки к состоянию
			по умолчанию. При этом удаляется подсветка для всех
			групп, определённых пользователем! Для выбора цветов
			по умолчанию применяется текущее значение опции
			'background'.

:hi[ghlight] clear {имя_группы}
:hi[ghlight] {имя_группы} NONE
			Команда отключает подсветку для указанной группы
			подсветки. При этом _не_ происходит назначения цвета
			по умолчанию.

:hi[ghlight] [default] {имя_группы} {имя}={параметр} ..
			Команда позволяет добавлять группу подсветки или
			изменять подсветку для существующей группы.
			Параметры {имя}={параметр} рассматриваются в разделе
			|подсветка-параметры|.
			Необязательный параметр [default] рассматривается 
			в разделе |:highlight-default|.

Обычно группа подсветки добавляется один раз при запуске, когда назначаются
значения для подсветки по умолчанию. Затем вы можете использовать
дополнительные команды подсветки для изменения необходимых параметров.
Значение "NONE" может применяться для отключения значения или возврата к
значению по умолчанию.

Простой способ изменения всех цветов предоставляет команда |:colorscheme|. Она
позволяет загружать специальный сценарий, в котором содержатся команды
":highlight" вроде
>
   :hi Comment	gui=bold

Обратите внимание, что все настройки, которые не включены в этот сценарий,
остаются без изменений и применяются только указанные поля, которые
смешиваются с использованными раннее. Таким образом, результат выполнения
команды будет таким же, как если бы была выполнена команда
>
   :hi Comment	term=bold ctermfg=Cyan guifg=#80a0ff gui=bold
<
					 *highlight-args* *E416* *E417* *E423*
					                 *подсветка-параметры*

С точки зрения подсветки имеется три типа терминалов:

term	обычный терминал (vt100, xterm)
cterm	цветной терминал (консоль MS-DOS, color-xterm, такие терминалы имеют
        запись "Co" в termcap)
gui	графический интерфейс

Подсветка может определяться для каждого типа терминала в отдельности. Это
позволяет использовать один и тот же файл синтаксиса для всех терминалов,
применяя оптимальный режим подсветки.

1. Параметры команды highlight для обычных терминалов

                                                           *список_параметров*
term={список_параметров}		   *attr-list* *highlight-term* *E418*
	список_параметров представляет собой список, состоящий из одного или
	нескольких нижеперечисленных значений (без пробелов), в любом порядке:

		bold		жирный
		underline       подчёркивание
		reverse         выворотка, инверсный видеорежим
		inverse		то же, что и reverse
		italic          наклонный шрифт
		standout        выделяющийся шрифт
		NONE		параметры не применяются (используется для
		                сброса параметров)

	Обратите внимание, что "bold" можно применять как в этом контексте,
	так и при использовании жирного шрифта. Эффект в обоих случаях будет
	одинаковым.

                                                      *список_кодов_терминала*
start={список_кодов_терминала}  		      *highlight-start* *E422*
stop={список_кодов_терминала}			  *term-list* *highlight-stop*
	Эти списки кодов терминала применяются для вывода нестандартных
	атрибутов на терминале.

	Экранирующие последовательности, заданные при помощи параметра
	"start", выводятся перед символами в подсвеченной области. Вы можете
	использовать любые последовательности, которые хотели бы применять для
	данной подсвеченной области. Экранирующая последовательность, заданная
	с помощью параметра "stop", выводится после подсвеченной области. Она
	должна отменять действие последовательности, заданной с помощью
	параметра "start", иначе вы можете столкнуться с появлением мусора на
	экране.

	{список_кодов_терминала} может быть двух видов:

	1. Строка с экранирующей последовательностью.
	   В такой строке можно использовать любые символы, кроме пробелов,
	   при условии, что она не начинается с "t_". Вы можете использовать
	   соглашение <>, например, задавать символы "<Esc>" или "<Space>".
	   Пример:
>
		start=<Esc>[27h;<Esc>[<Space>r;
<
	2. Список кодов терминала.
	   Каждый код терминала имеет вид "t_xx", где "xx" это имя записи в
	   termcap.  Коды должны быть разделены запятыми. Пробелы не
	   допускаются. Пример:
>
		start=t_C1,t_BL
<
	   Учтите, что указанные коды терминала должны существовать, иначе
	   команда работать не будет.


2. Параметры команды highlight для цветных терминалов

cterm={список_параметров}				     *highlight-cterm*
        {список_параметров} рассматривается выше, см. |список_параметров|.
	Значение параметра "cterm" скорее всего будет отличаться от значения
	"term" при использовании цветов. Например, комментарии на обычном
	терминале могут подчёркиваться, тогда как на цветном терминале они
	могут отображаться синим цветом.
	Замечание: многие терминалы (например, консоль DOS) не могут смешивать
	обсуждаемые здесь параметры при выполнении подсветки. Используйте
	только "cterm=" ИЛИ "ctermfg=" ИЛИ "ctermbg".

ctermfg={номер_цвета}				    *highlight-ctermfg* *E421*
ctermbg={номер_цвета}				           *highlight-ctermbg*
        Параметр {номер_цвета} используется для указания цвета по номеру в
	диапазоне от ноля до числа, на единицу меньшего, чем значение записи
	termcap "Co" (включительно). Конкретный цвет, соответствующий этому
	числу, зависит от типа терминала и его настроек. Цвет также иногда
	зависит от настроек "cterm". Например, на некоторых системах
	"cterm=bold ctermfg=3" приводит к другому цвету, отличному от цвета со
	значением 3.

	В xterm цвета могут быть довольно непредсказуемыми и зависеть от
	соответствующих ресурсов. Значения по умолчанию приводятся в
	документации по xterm. Цвета для color-xterm могут быть изменены 
	в файле .Xdefaults. К сожалению, это приводит к тому, что вы не можете
	добиться того, чтобы цвета были одинаковыми для всех пользователей.
	Дополнительная информация о цветных xterm приводится в разделе
	|xterm-цвет|.

	Стандартные цвета MSDOS являются неизменяемыми (в окне консоли),
	поэтому они были взяты в качестве имён. В то же время, в X11
	неизменяемым является значение имён цветов, поэтому эти настройки
	цветов используются для переносимых настроек подсветки (ещё не
	запутались?). Ниже приводятся имена цветов, которые могут
	распознаваться в Vim, с соответствующими им номерами:

					          *cterm-colors* *cterm-цвета*
	    NR-16   NR-8    ИМЯ ЦВЕТА ~
	    0	    0	    Black (чёрный)
	    1	    4	    DarkBlue (тёмно-синий)
	    2	    2	    DarkGreen (тёмно-зелёный)
	    3	    6	    DarkCyan (тёмно-голубой)
	    4	    1	    DarkRed (тёмно-красный)
	    5	    5	    DarkMagenta (пурпурный)
	    6	    3	    Brown, DarkYellow (коричневый)
	    7	    7	    LightGray, LightGrey, Gray, Grey (серый)
	    8	    0*	    DarkGray, DarkGrey (тёмно-серый)
	    9	    4*	    Blue, LightBlue (синий)
	    10	    2*	    Green, LightGreen (зелёный)
	    11	    6*	    Cyan, LightCyan (голубой)
	    12	    1*	    Red, LightRed (красный)
	    13	    5*	    Magenta, LightMagenta (светло-малиновый)
	    14	    3*	    Yellow, LightYellow (жёлтый)
	    15	    7*	    White (белый)

	Число в колонке "NR-16" используется на 16-цветных терминалах (где
	значение 't_Co' больше или равно 16). Число в колонке "NR-8"
	используется на 8-цветных терминалах (где значение опции 't_Co' 
	меньше 16). Звёздочка ('*') указывает, что для ctermfg устанавливается
	атрибут bold. На многих 8-цветных терминалах (например, "linux") это
	приводит к использованию ярких цветов. Однако, это не работает с
	цветами фона! Там, где '*' не указана, атрибут bold удаляется. Если вы
	хотите назначать атрибут bold иным способом, помещайте параметр
	"cterm=" ПОСЛЕ параметра "ctermfg=" или "ctermbg=", либо используйте
	номер цвета, а не его имя.

	Регистр символов в имени цвета игнорируется.
	Обратите внимание, что на 16-цветных ansi-терминалах (включая xterm)
	применяются значения, указанные в колонке NR-8. В этом случае *
	обозначает добавление 8, так что цвету Blue соответствует номер 12,
	цвету DarkGray -- 8, и т.д.

	Заметим, что на некоторых цветных терминалах использование имён может
	приводить к неправильным цветам!

							    *:hi-normal-cterm*
	Цвета, назначенные группе Normal при помощи параметров "ctermfg" и
	"ctermbg", используются для подсветки обычного (неподсвеченного)
	текста. Например:
>
		:highlight Normal ctermfg=grey ctermbg=darkblue
<	
	При назначении цвета "ctermbg" для группы Normal значение опции
	'background' изменяется соответствующим образом автоматически. Это
	приводит к тому, что группы подсветки, полагающиеся на значение опции
	'background', будут изменены! Таким образом, прежде всего следует
	назначать цвета группе Normal, а уже затем изменять значения других
	цветов.
	
	Если вы используете ту или иную цветовую схему, то при изменении
	значения опции 'background' происходить перезагрузка цветовой схемы,
	что может приводить к сбросу всех цветов, включая подсветку группы
	Normal. Если вас это не устраивает, то перед изменением значения
	'background' следует удалить переменную "colors_name".

	После настройки "ctermfg" или "ctermbg" для группы Normal Vim должен
	сбросить цвета перед прекращением работы. Это выполняется при помощи
	записи termcap "op", см. |t_op|. Если на вашем компьютере данная
	операция выполняется некорректно, попытайтесь изменить значение опции
	't_op' в сценарии загрузки .vimrc.

							         *E419* *E420*
	В том случае, если Vim знает нормальные цвета для текста и фона, на
	них можно ссылаться с помощью имён "fg" и "bg". Эта возможность
	работает только после назначения цветов для группы Normal или
	в консоли MS-DOS. Например, для режима выворотки можно использовать
	такую команду:
>
	    :highlight Visual ctermfg=bg ctermbg=fg
<	
	Обратите внимание, что настройки цветов вступают в силу с момента
	выполнения команды. Если позднее вы измените значения цветов группы
	Normal, то цвета "fg" и "bg" изменены не будут.


3. Параметры команды highlight для графического интерфейса

gui={список_параметров}				               *highlight-gui*
	Данная команда позволяет задавать настройки цветов для использования в
	режиме графического интерфейса.
        {список_параметров} рассматривается выше, см. |список_параметров|.
	
	Обратите внимание, что "bold" можно применять как в этом контексте,
	так и при использовании жирного шрифта. Эффект в обоих случаях будет
	одинаковым.
	Указанные параметры игнорируются для группы "Normal".

font={имя_шрифта}					      *highlight-font*
	В качестве {имени_шрифта} используется имя шрифта в той форме, 
	в которой он доступен на системе, где запущен Vim. На X11 такие имена
	выглядят довольно сложно, например:
>
        font=-misc-fixed-bold-r-normal--14-130-75-75-c-70-iso8859-1
<
	Имя шрифта "NONE" применяется для возврата к шрифту по умолчанию. Если
	речь идёт о назначении шрифта группе "Normal", то такой шрифт
	становится шрифтом по умолчанию, до тех пор, пока не будет изменена
	опция 'guifont'. В качестве шрифта по умолчанию всегда используется
	шрифт для группы Normal или значение опции 'guifont', в зависимости от
	того, какое значение было изменено последним.
	
	В Motif и Athena (но не в других системах графического интерфейса) при
	изменении шрифта для группы "Menu" будут изменён шрифт в меню, а при
	изменении шрифта для группы "Tooltip" будет изменён шрифт во
	всплывающих подсказках.
	При использовании любого шрифта, за исключением групп Menu и Tooltip,
	его размер должен совпадать с размером шрифта по умолчанию! 
	В противном случае будут возникать проблемы при обновлении экрана.

guifg={имя_цвета}					     *highlight-guifg*
guibg={имя_цвета}					     *highlight-guibg*
	Эти параметры задают цвета текста (guifg) и фона (guibg) при
	использовании графического интерфейса. В качестве значений этих
	параметров можно использовать также специальные имена:

		NONE		цвет отсутствует (прозрачный)
		bg		использовать обычный цвет фона
		background	использовать обычный цвет фона
		fg		использовать обычный цвет текста
		foreground	использовать обычный цвет текста
		
	Чтобы задать цвет, имя которого содержит пробел или какой-либо другой
	спецсимвол, поместите имя в одиночные кавычки. В этом случае в имени
	нельзя использовать символ одиночной кавычки. Например:
>
	    :hi comment guifg='salmon pink'
<
			            *gui-colors* *графический_интерфейс-цвета*
	Приводим список рекомендуемых имён цветов, которые доступны на
	большинстве систем:

	    Red		    (Красный)	
	    LightRed	    (Светло-красный) 
	    DarkRed	    (Тёмно-красный)	    
	    Green	    (Зелёный)
	    LightGreen	    (Светло-зелёный)
	    DarkGreen	    (Тёмно-зелёный)
	    SeaGreen	    (Цвет морской волны)
	    Blue	    (Синий)
	    LightBlue	    (Светло-синий)
	    DarkBlue	    (Тёмно-синий)
	    SlateBlue	    (Серо-синий)
	    Cyan	    (Голубой)
	    LightCyan	    (Светло-голубой)
	    DarkCyan	    (Тёмно-голубой)
	    Magenta	    (Малиновый)
	    LightMagenta    (Светло-малиновый)
	    DarkMagenta	    (Тёмно-малиновый)
	    Yellow	    (Жёлтый)
	    LightYellow	    (Светло-жёлтый)
	    Brown	    (Коричневый)
	    DarkYellow	    (Тёмно-жёлтый)
	    Gray	    (Серый)
	    LightGray	    (Светло-серый)
	    DarkGray	    (Тёмно-серый)
	    Black	    (Чёрный)
	    White	    (Белый)
	    Orange	    (Оранжевый)
	    Purple	    (Пурпурный)
	    Violet	    (Фиолетовый)

	В версии с графическим интерфейсом для Win32 доступен ряд
	дополнительных цветов. Их список приводится в разделе |win32-цвета|.

	Вы можете также задать цвет с помощью значений красного, зелёного и
	синего компонентов, используя формат "#rrggbb", где
	
		"rr"	значение красного
		"bb"	значение синего
		"gg"	значение зелёного
		
	Все значения даются в шестнадцатеричной форме, в диапазоне от "00" до
	"ff". Например:
>
        :highlight Comment guifg=#11f0c3 guibg=#ff00ff
<
					 *highlight-groups* *подсветка-группы*
				  *highlight-default* *подсветка-по_умолчанию*
Ниже приводится список групп подсветки, заданных по умолчанию. Эти группы
используются в значении опции 'highlight' по умолчанию. Обратите внимание, что
подсветка зависит от значения опции 'background'. Текущие настройки можно
посмотреть с помощью команды ":highlight".

					        *hl-Cursor* *подсветка-Cursor*
Cursor		символ в позиции курсора

					    *hl-CursorIM* *подсветка-CursorIM*
CursorIM	то же, что и Cursor, но при использовании в режиме редактора
                метода ввода (IME). См. |CursorIM|.
		
				          *hl-Directory* *подсветка-Directory*
Directory	имена каталогов (и другие специальные имена в списках)

					      *hl-DiffAdd* *подсветка-DiffAdd*
DiffAdd		в режиме сверки различий (diff): добавленная строка, 
		см. |diff.txt|
		
				        *hl-DiffChange* *подсветка-DiffChange*
DiffChange	в режиме сверки различий (diff): изменённая строка,
		см. |diff.txt|
		
				        *hl-DiffDelete* *подсветка-DiffDelete*
DiffDelete	в режиме сверки различий (diff): удалённая строка,
		см. |diff.txt|
		
				            *hl-DiffText* *подсветка-DiffText*
DiffText	в режиме сверки различий (diff): изменённый текст в изменённой
                строке. См. |diff.txt|.
		
					    *hl-ErrorMsg* *подсветка-ErrorMsg*
ErrorMsg	сообщения об ошибках в командной строке

					  *hl-VertSplit* *подсветка-VertSplit*
VertSplit	колонка, разделяющая два окна по вертикали

					        *hl-Folded* *подсветка-Folded*
Folded		строка, используемая для закрытых складок

				        *hl-FoldColumn* *подсветка-FoldColumn*
FoldColumn	'foldcolumn'

					*hl-SignColumn* *подсветка-SignColumn*
SignColumn	колонка, в которой отображаются |значки|

					  *hl-IncSearch* *подсветка-IncSearch*
IncSearch	Подсветка для 'incsearch'; также применяется для подсветки
		текста, заменённого по команде ":s///c"
		
					        *hl-LineNr* *подсветка-LineNr*
LineNr		номер строки для команд ":number" и ":#", а также для
                отображения номеров строк при включённой опции 'number'.

					      *hl-ModeMsg* *подсветка-ModeMsg*
ModeMsg		Сообщение 'showmode' (например, "-- ВСТАВКА --")

					      *hl-MoreMsg* *подсветка-MoreMsg*
MoreMsg		|продолжение_следует|

					      *hl-NonText* *подсветка-NonText*
NonText		'~' и '@' в конце окна, символы опции 'showbreak' и другие
		символы, которые не существуют в тексте (например, символ ">",
		который появляется в конце строки, когда символ двойной ширины
		не помещается на строке).
		
					        *hl-Normal* *подсветка-Normal*
Normal		обычный текст
					    *hl-Question* *подсветка-Question*
Question	Приглашение |нажмите-enter| и вопросы Да/Нет.

					        *hl-Search* *подсветка-Search*
Search		подсветка соответствий последнему использованному шаблону
                поиска (см. 'hlsearch').
		Также применяется для подсветки текущей строки в окне быстрых
		исправлений и других подобных элементов, которые нуждаются в
		выделении.

					*hl-SpecialKey* *подсветка-SpecialKey*
SpecialKey	метакнопки и спецкнопки, которые отображаются в выводе команды
		":map", в том числе при отображении непечатных символов в
		тексте, а также символы, используемые в опции 'listchars'. 
		В общем случае эта группа применяется для подсветки текста,
		который отображается иначе, чем он является на самом деле.
		
					*hl-StatusLine* *подсветка-StatusLine*
StatusLine	строка состояния активного окна

				    *hl-StatusLineNC* *подсветка-StatusLineNC*
StatusLineNC	строка состояния неактивных окон.
		Замечание: если эта группа равнозначна группе "StatusLine", то
		Vim будет использовать "^^^" в строке состояния активного
		окна.
		
					          *hl-Title* *подсветка-Title*
Title		заголовки, применяемые в выводе команд ":set all", ":autocmd"
		и т.д.

						*hl-Visual* *подсветка-Visual*
Visual		выделение в Визуальном режиме

					  *hl-VisualNOS* *подсветка-VisualNOS*
VisualNOS	выделение в Визуальном режиме для тех случаев, когда Vim не
		является "владельцем" выделения.
		Применяется только в графическом интерфейсе X11 
		(см. |графический_интерфейс-X11|) и при работе с буфером
		обмена xterm (см. |xterm-буфер_обмена|).

				        *hl-WarningMsg* *подсветка-WarningMsg*
WarningMsg	предупреждения

				            *hl-WildMenu* *подсветка-WildMenu*
WildMenu	текущее соответствие при использовании автодополнения
		'wildmenu'

			                              *hl-User1* *hl-User1..9*
			                *подсветка-User1* *подсветка-User1..9*
Синтаксис опции 'statusline' позволяет использовать до 9 различных
пользовательских групп в строке состояния и в линейке (при помощи опции
'rulerformat'). Эти группы имеют имена от User1 до User9.

В графическом интерфейсе вы можете также использовать нижеследующие группы для
настройки цветов для меню, полос прокрутки и всплывающих подсказок. Эти группы
не имеют значений по умолчанию и не работают в графическом интерфейсе Win32.
Для данных групп подсветки применимы только три параметра: font, guibg 
и guifg.

					            *hl-Menu* *подсветка-Menu*
Menu		Текущий шрифт и цвета фона и текста для меню. Эта группа также
		используется для инструментальной панели.
		Допустимо использование следующих параметров подсветки: font,
		guibg, guifg.

		ЗАМЕЧАНИЕ: В Motif и Athena параметр font в действительности
		задаёт шрифтовой набор во всех случаях, независимо от того,
		является ли значение опции 'guifontset' пустой строкой. Данный
		шрифтовой набор привязывается к активному языку в момент
		назначения (см. |:language|).

					  *hl-Scrollbar* *подсветка-Scrollbar*
Scrollbar	Текущие цвета фона и текста полос прокрутки основного окна.
		Допустимо использование следующих параметров подсветки: guibg,
		guifg.

					      *hl-Tooltip* *подсветка-Tooltip*
Tooltip		Текущий шрифт и цвета фона и текста для всплывающих подсказок.
		Допустимо использование следующих параметров подсветки: font,
		guibg, guifg.

		ЗАМЕЧАНИЕ: В Motif и Athena параметр font в действительности
		задаёт шрифтовой набор во всех случаях, независимо от того,
		является ли значение опции 'guifontset' пустой строкой. Данный
		шрифтовой набор привязывается к активному языку в момент
		назначения (см. |:language|).

==============================================================================
13. Связывание групп	            *:hi-link* *:highlight-link* *E412* *E413*

Если вы хотите использовать одни и те же настройки подсветки для нескольких
синтаксических групп, то проще всего это сделать путём связывания этих групп 
с одной общей группой подсветки, а параметры подсветки назначить только этой
одной группе.

Чтобы установить связь:

    :hi[ghlight][!] [default] link {от_группы} {к_группе}

Для удаления связи:

    :hi[ghlight][!] [default] link {от_группы} NONE

Замечания:						                *E414*

- Если группа {от_группы} и/или группа {к_группе} не существует, то она будет
  создана при выполнении данной команды. Сообщений об ошибке, связанной с
  несуществующей группой, не выдаётся.
- Как только будет выполнена команда ":highlight" для связанной группы, связь
  будет удалена.
- Если настройки подсветки для группы {от_группы} уже были определены, то
  связь не будет создана при использовании команды связи без '!'. 
  При использовании команды ":highlight link" в файле сценария сообщение об
  ошибке не выдаётся. Этим можно пользоваться для пропуска ссылок для тех
  групп, которым уже назначены параметры.

					    *:hi-default* *:highlight-default*
Параметр [default] используется для настройки подсветки по умолчанию для
данной группы. Если подсветка для данной группы уже была назначена, то эта
команда будет пропущена. То же самое касается существующих связей групп.

Использование параметра [default] особенно полезно для переопределения
подсветки, заданной в определённом файле сценария синтаксиса. Например,
сценарий синтаксиса для языка C содержит следующую команду:
>
	:highlight default link cComment Comment

Если вы хотите использовать для комментариев в тексте на языке C подсветку
группы Question, то достаточно поместить в сценарии запуска vimrc следующую
строку:
>
	:highlight link cComment Question

Без параметра "default" в сценарии синтаксиса языка C подсветка была бы
переназначена при загрузке файла сценария синтаксиса.

==============================================================================
14. Очистка синтаксиса					   *:syn-clear* *E391*

Если вы желаете очистить настройки синтаксиса для текущего буфера, то вам
следует воспользоваться следующей командой:
>
  :syntax clear

Эта команда применяется в тех случаях, когда необходимо отключить подсветку
синтаксиса или применить новые правила подсветки синтаксиса. Включать её в
сценарий подсветки синтаксиса обычно нет необходимости, поскольку синтаксис
очищается при помощи автокоманд, выполняющих загрузку сценария подсветки
синтаксиса.

Данная команда также удаляет переменную "b:current_syntax", поскольку после её
выполнения правила подсветки синтаксиса перестают существовать.

Если вы хотите отключить подсветку синтаксиса для всех буферов, то вам
потребуется удалить автокоманды, которые выполняют загрузку сценариев
подсветки синтаксиса:
>
  :syntax off

При выполнении этой команды в действительности происходит выполнение команды
>
  :source $VIMRUNTIME/syntax/nosyntax.vim

Подробнее об этом вы можете узнать, изучив сценарий "nosyntax.vim". Обратите
внимание, что для успешного выполнения этой команды необходимо, чтобы
переменная $VIMRUNTIME имела правильное значение. Подробнее об этом 
см. в разделе |$VIMRUNTIME|.

Для очистки отдельной синтаксической группы в текущем буфере применяйте
следующую команду:
>
  :syntax clear {имя_группы} ...
  
Данная команда удаляет все шаблоны и ключевые слова для группы с указанным
{именем_группы}.

Для очистки определённых списков синтаксических групп в текущем буфере
пользуйтесь командой:
>
  :syntax clear @{имя_списка_групп} ...
  
При этом содержимое списка с указанным {именем_списка_групп} будет сделано
пустым.

						  *:syntax-reset* *:syn-reset*
Если вы хотите вернуться к настройкам подсветки по умолчанию после того, как
внесли в них какие-либо изменения, воспользуйтесь командой
>
  :syntax reset

Цвета для подсветки, связанной с работой опции 'highlight', при этом не
изменяются.

Обратите внимание, что настройки подсветки, установленные в сценарии vimrc,
при этом также будут сброшены к принятым в Vim по умолчанию. Кроме того, также
будут утрачены цвета подсветки, определённые при загрузке цветовой схемы.

При выполнении этой команды на самом деле происходит отработка следующего
сценария:
>
	let g:syntax_cmd = "reset"
	runtime! syntax/syncolor.vim

Обратите внимание на использование значения опции 'runtimepath'.

							            *syncolor*
Если вы желаете использовать другие цвета для подсветки синтаксиса, то вы
можете создать специальный сценарий для настройки этих цветов. Этот сценарий
следует поместить в одном из каталогов, указанных в значении опции
'runtimepath' после $VIMRUNTIME, чтобы ваши настройки имели приоритетное
значение перед цветами по умолчанию. В этом случае определённые вами цвета
будут использованы после выполнения команды ":syntax reset".

В Unix вы можете использовать файл ~/.vim/after/syntax/syncolor.vim. Например:
>
	if &background == "light"
	  highlight comment ctermfg=darkgreen guifg=darkgreen
	else
	  highlight comment ctermfg=green guifg=green
	endif

Заметим, что использование данных цветов может быть переопределено в сценарии
цветовой схемы. Подробнее об этом см. в разделе |:colorscheme|.

							          *syntax_cmd*
Переменная "syntax_cmd" может иметь одно из нижеперечисленных значений,
которое присваивается при загрузке сценария syntax/syncolor.vim:

   "on"		Команда ":syntax on".  Цвета подсветки переопределяются,
                однако существующие связи сохраняются.
   "enable"	Команда ":syntax enable".  Определяются только цвета для
                групп, которым ещё не назначены параметры подсветки.
		Используйте ":syntax default".
   "reset"	Команда ":syntax reset" или загрузка цветовой схемы.
		Определять следует все цвета.
   "skip"	Цвета не определяются. Используется для пропуска настроек по
		умолчанию, если сценарий syncolor.vim в одном из каталогов,
		указанных в значении опции 'runtimepath', уже назначил их.

==============================================================================
15. Подсветка меток			     *tag-highlight* *метки-подсветка*

Если вы хотите организовать подсветку всех меток в файле, то можете
использовать указанные ниже привязки.

	<F11>	-- Создать файл tags.vim и выполнить подсветку меток.
	<F12>	-- Включить подсветку меток на основании существующего файла
	           tags.vim.
>
  :map <F11>  :sp tags<CR>:%s/^\([^	:]*:\)\=\([^	]*\).*/syntax keyword Tag \2/<CR>:wq! tags.vim<CR>/^<CR><F12>
  :map <F12>  :so tags.vim<CR>

ПРЕДУПРЕЖДЕНИЕ: Чем длиннее файл меток, тем медленнее будет выполняться
подсветка и тем больше памяти будет требоваться для работы Vim.

Вы также можете выполнять подсветку только для определений типов (typedef),
объединений (union) и структур (struct). Для этого вам потребуется
использовать программу Exuberant ctags (её можно загрузить по адресу
http://ctags.sf.net).

Создайте файл Makefile следующего содержания:
>
---------------------------------------------------------------
# Создание файла подсветки для типов. Требует наличия программ
# Exuberant ctags и awk.

types: types.vim
types.vim: *.[ch]
	ctags -i=gstuS -o- *.[ch] |\
		awk 'BEGIN{printf("syntax keyword Type\t")}\
			{printf("%s ", $$1)}END{print ""}' > $@
---------------------------------------------------------------

Для использования поместите следующие строки в сценарий .vimrc:
>
   " загрузка сценария подсветки types.vim, если он существует
   "
   autocmd BufRead,BufNewFile *.[ch] let fname = expand('<afile>:p:h') . '/types.vim'
   autocmd BufRead,BufNewFile *.[ch] if filereadable(fname)
   autocmd BufRead,BufNewFile *.[ch]   exe 'so ' . fname
   autocmd BufRead,BufNewFile *.[ch] endif

==============================================================================
16. Цветные терминалы xterm	      *xterm-color* *color-xterm* *xterm-цвет*

Большинство цветных терминалов xterm имеет только восемь цветов. Если при
использовании настроек по умолчанию вам не удаётся получить цвета на
терминале, то попробуйте добавить в сценарий .vimrc следующие строки:
>
   :if &term =~ "xterm"
   :  if has("terminfo")
   :	set t_Co=8
   :	set t_Sf=<Esc>[3%p1%dm
   :	set t_Sb=<Esc>[4%p1%dm
   :  else
   :	set t_Co=8
   :	set t_Sf=<Esc>[3%dm
   :	set t_Sb=<Esc>[4%dm
   :  endif
   :endif
   
<  [здесь <Esc> это код кнопки <Esc>, при вводе набирайте CTRL-V <Esc>]

Вы можете заменить в первом "if" имя терминала в соответствии с вашими
условиями. Например, вместо "xterm" можно использовать "dtterm".

Замечание: Эти настройки должны вступить в силу ДО ВЫПОЛНЕНИЯ команды 
":syntax on", иначе цвета будут отображаться неправильно.

							       *xiterm* *rxvt*
Вышеуказанные настройки также работают на xiterm и rxvt. Однако, для
использования 16 цветов в rxvt следует воспользоваться следующими настройками
terminfo:
>
	:set t_AB=<Esc>[%?%p1%{8}%<%t25;%p1%{40}%+%e5;%p1%{32}%+%;%dm
	:set t_AF=<Esc>[%?%p1%{8}%<%t22;%p1%{30}%+%e1;%p1%{22}%+%;%dm
<
							       *colortest.vim*
Для проверки настройки цветов в поставку Vim включён специальный сценарий.
Чтобы воспользоваться им, применяйте следующие команды:
>
   :e $VIMRUNTIME/syntax/colortest.vim
   :so %

На некоторых версиях xterm (и ряде других терминалов, например в консоли
linux) возможен вывод светлых цветов текста, несмотря на то, что количество
цветов определено равным 8. По этой причине Vim включает параметр cterm=bold
для светлых цветов текста, если значение 't_Co' равно 8.

							         *xfree-xterm*
Чтобы использовать 16 и более цветов, применяйте свежую версию xterm
(например, включённую в состав Xfree86 3.3 или более поздней версии). Самую
последнюю версию xterm также можно найти в интернете по адресу
>
    http://invisible-island.net/xterm/xterm.html

Ниже приводится информация о конфигурации этого терминала, позволяющая не
только получить 88 цветов, но и включить особенность опроса termcap, которая
помогает Vim узнать какое именно количество цветов используется на данном
терминале.
>
    ./configure --disable-bold-color --enable-88-color --enable-tcap-query

Если вы видите только 8 цветов, проверьте настройки компиляции xterm.
(См. также раздел |UTF8-xterm|, где описывается использование xterm с
символами в кодировке UTF-8).

Такой xterm должен работать при использовании следующих строк в сценарии
.vimrc (для 16 цветов):
>
   :if has("terminfo")
   :  set t_Co=16
   :  set t_AB=<Esc>[%?%p1%{8}%<%t%p1%{40}%+%e%p1%{92}%+%;%dm
   :  set t_AF=<Esc>[%?%p1%{8}%<%t%p1%{30}%+%e%p1%{82}%+%;%dm
   :else
   :  set t_Co=16
   :  set t_Sf=<Esc>[3%dm
   :  set t_Sb=<Esc>[4%dm
   :endif
<
   [здесь <Esc> это код кнопки <Esc>, при вводе набирайте CTRL-V <Esc>]

Vim сможет распознать указанные настройки без особенности |+terminfo| и
автоматически перевести цвета cterm со значениями от 8 и выше в формат
"<Esc>[9%dm" и "<Esc>[10%dm". Цвета со значениями больше 16 также переводятся
автоматически.

Имеются сведения, что команды
>
   :set t_AB=<Esc>[48;5;%dm
   :set t_AF=<Esc>[38;5;%dm

позволяют включить 356 цветов.

С другой стороны, вы можете присвоить переменной окружения TERM значение
"xterm-color" или "xterm-16color", возможно этого будет достаточно.

Вам может понадобиться использовать следующие ресурсы X
(в файле ~/.Xdefaults):

	XTerm*color0:			#000000
	XTerm*color1:			#c00000
	XTerm*color2:			#008000
	XTerm*color3:			#808000
	XTerm*color4:			#0000c0
	XTerm*color5:			#c000c0
	XTerm*color6:			#008080
	XTerm*color7:			#c0c0c0
	XTerm*color8:			#808080
	XTerm*color9:			#ff6060
	XTerm*color10:			#00ff00
	XTerm*color11:			#ffff00
	XTerm*color12:			#8080ff
	XTerm*color13:			#ff40ff
	XTerm*color14:			#00ffff
	XTerm*color15:			#ffffff
	Xterm*cursorColor:		Black

[Замечание: cursorColor необходим для того, чтобы обойти глюк, из-за которого
цвет курсора заменяется на цвет последнего отрисованного символа текста. Этот
глюк был исправлен в последних версиях xterm, но не все её ещё используют.]

После описания указанных ресурсов, поместите файл .Xdefaults в базу данных 
X Option Manager (это нужно делать всякий раз, когда вы изменяете файл
.Xdefaults):
>
  xrdb -merge ~/.Xdefaults
<
		         *xterm-blink* *xterm-blinking-cursor* *xterm-мигание*
Чтобы включить мигание курсора в xterm, посмотрите входящую в поставку Vim
программу tools/blink.c. 

Вы также можете воспользоваться xterm Томаса Дикки [Thomas Dickey] с
заплатками уровня 107 или более поздний (адрес в интернете, где можно взять
этот xterm, указан выше). При этом вам потребуются следующие ресурсы:

	XTerm*cursorBlink:	on
	XTerm*cursorOnTime:	400
	XTerm*cursorOffTime:	250
	XTerm*cursorColor:	White

				                  *hpterm-color* *hpterm-цвет*
Для hpterm, который поддерживает только 8 цветов текста, в той или иной
степени полезными могут быть следующие настройки:
>
   :if has("terminfo")
   :  set t_Co=8
   :  set t_Sf=<Esc>[&v%p1%dS
   :  set t_Sb=<Esc>[&v7S
   :else
   :  set t_Co=8
   :  set t_Sf=<Esc>[&v%dS
   :  set t_Sb=<Esc>[&v7S
   :endif
<
   [здесь <Esc> это код кнопки <Esc>, при вводе набирайте CTRL-V <Esc>]

			                        *Eterm* *enlightened-terminal*
У нас имеются сведения, что нижеприведённые настройки работают на эмуляторе
Enlightened terminal (Eterm). Они могут применяться для всех xterm-подобных
терминалов, которые используют параметр bold для получения ярких цветов. При
необходимости можете добавить проверку "if", как это показано в
вышеприведённых примерах:
>
       :set t_Co=16
       :set t_AF=^[[%?%p1%{8}%<%t3%p1%d%e%p1%{22}%+%d;1%;m
       :set t_AB=^[[%?%p1%{8}%<%t4%p1%d%e%p1%{32}%+%d;1%;m
<
						                *TTpro-telnet*
Нижеуказанные настройки должны быть работоспособными на TTpro telnet. 
(Tera Term Pro это бесплатная программа с открытым исходным кодом для
MS-Windows).
>
	set t_Co=16
	set t_AB=^[[%?%p1%{8}%<%t%p1%{40}%+%e%p1%{32}%+5;%;%dm
	set t_AF=^[[%?%p1%{8}%<%t%p1%{30}%+%e%p1%{22}%+1;%;%dm

Убедитесь, что в настройках TTpro включена поддержка цвета 
(Setup/Window/Full Color), а поддержка жирного шрифта (Setup/Font/Enable Bold)
выключена.

(эта информация предоставлена Джоном Лав-Дженсеном [John Love-Jensen],
<eljay@Adobe.COM>)

==============================================================================
 vim:tw=78:sw=4:ts=8:ft=help:norl:
